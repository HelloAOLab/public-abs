{"version":1,"state":{"028365a4-036f-41d0-9af1-715ad4f2aa7a":{"id":"028365a4-036f-41d0-9af1-715ad4f2aa7a","space":"shared","tags":{"system":"ab.shell.regulate","form":"nothing","onAnyBotDrag":"@//controls grid snap\nif (links.remember.tags.abGridSnapState)\n{\n    os.addDropSnap(\"grid\");\n}\n\n//controls bot snap\nif (links.remember.tags.abBotSnapState)\n{\n    os.addDropSnap(\"face\");\n}","remember":"🔗e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","abIgnore":"true","abBotVersion":54,"abShell":"true"}},"10142546-8c34-4bd6-ad36-0a1461793d09":{"id":"10142546-8c34-4bd6-ad36-0a1461793d09","space":"shared","tags":{"abID":"abrw_test_experience","eggFormatVersion":"0170d8ba-17c0-42c6-80e9-2b15d3cd75c7","targetVersion":1,"manager":"🔗d8371444-9158-4436-8fc7-84cc91b7f525","onClick":"@ links.manager.interactOvo(thisBot);","onCreate":"@const targetAB = await os.showInput('ab', {\n    title: 'ab name'\n});\n\nif (!targetAB || targetAB == \"ab\")\n{\n    os.toast(\"no valid ab given\");\n\n    destroy(thisBot);\n\n    return;\n}\n\nconst getRecord = await os.getData(links.remember.tags.abRecordKey, targetAB, links.remember.tags.abEndpoint);\n\nif (!getRecord.success)\n{\n    os.toast(\"no ab found with that name\");\n\n    destroy(thisBot);\n\n    return;\n}\n\napplyMod(thisBot, getRecord.data);","form":"egg","progressBarColor":"#BF5E66","progressBarBackgroundColor":"#592989","labelSize":0.5,"labelColor":"#404040","onPointerEnter":"@os.toast(tags.abID + ' v'+tags.targetVersion);","labelPosition":"front","orientationMode":"billboardFront","onDestroy":"@links.manager.masks.ovoBot = null;","dimension":"home","system":"ab.factory.egg","listening":"false","abFactory":"true","abIgnore":"true","remember":"🔗e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","factoryIcon":"egg","color":"#FFFFFF","abBotVersion":15,"abMenuSortOrder":"3"}},"14e1fdac-cfd7-4e7e-bdd1-967a4085a755":{"id":"14e1fdac-cfd7-4e7e-bdd1-967a4085a755","space":"shared","tags":{"system":"ab.factory.manager","form":"nothing","abIgnore":"true","abAddToFactory":"@//shout(\"abAddToFactory\", {dimension: dimension, bot: bot, factoryID: factoryID});\nlet factoryID;\n\nif (that.factoryID)\n{\n    factoryID = that.factoryID;\n}\nelse\n{\n    factoryID = await os.showInput(null, {\n        title: 'Add factory id'\n    });\n}\n\nif (factoryID)\n{\n    let previousFactoryBot = getBot(\"system\", \"ab.factory.\" + factoryID);\n    \n    if(previousFactoryBot)\n    {\n        destroy(previousFactoryBot);\n    }\n\n    let templateBot = that.bot;\n    let factoryMod = {};\n\n    factoryMod[that.dimension] = null;\n    factoryMod.system = \"ab.factory.\" + factoryID;\n    factoryMod.listening = false;\n    factoryMod.abFactory = true;\n\n    create(templateBot, factoryMod);\n\n    ab.log(factoryID + \" added to factory\");\n\n    os.toast(\"added \" + factoryID + \" to factory\");\n}","abFactory":"true","abBotMenuAction":"@const currentDim = links.manifestation.links.abBot.tags.dimension;\nconst targetBot = links.remember.links.abBotFocus;\n\nthisBot.abAddToFactory({dimension: currentDim, bot: targetBot});","abCreateFromFactory":"@//shout(\"abCreateFromFactory\", {factoryID: \"factoryID\", position: {dimension: \"dimension\", x: \"x\", y: \"y\"}});\nlet fullName = \"ab.factory.\" + that.factoryID;\nlet factoryTemplate = getMod(getBot('system', fullName));\nlet positionInfo = that.position;\n\nif(!factoryTemplate)\n{\n    console.log(\"not factory bot found\");\n\n    ab.log(fullName + \" could not be found\")\n\n    return;\n}\n\nab.log(fullName + \" created from factory\");\n\nlet newBot = {}\n\nnewBot.creator = null;\nnewBot[positionInfo.dimension] = true;\nnewBot[positionInfo.dimension + \"X\"] = positionInfo.position.x;\nnewBot[positionInfo.dimension + \"Y\"] = positionInfo.position.y;\nnewBot.listening = null;\nnewBot.abIgnore = null;\nnewBot.system = null;\nnewBot.abFactory = null;\nnewBot.abMenuSortOrder = null;\n\ncreate(factoryTemplate, newBot);\n\nlinks.manifestation.abClick();","abGridMenuAction":"@shout(\"abMenuRefresh\");\n\nconfigBot.masks.menuPortal = \"abMenu\";\n\nlinks.menu.masks.onGridClick = \"@ shout('abMenuRefresh'); links.manifestation.abClick();\";\n\nconst factoryBots = getBots(\"abFactory\");\nconst menuButton = {};\n\nmenuButton.abMenu = true;\nmenuButton.abMenuRefresh = \"@ destroy(thisBot);\";\nmenuButton.gridInformation = links.remember.tags.abGridFocus;\nmenuButton.manager = \"🔗\" + thisBot.id;\nmenuButton.onClick = `@ links.manager.abCreateFromFactory({factoryID: tags.label, position: tags.gridInformation}); shout('abMenuRefresh');`;\n\nif (factoryBots.length < 2)\n{\n    return; \n}\n\nfor (let j = 0; j < factoryBots.length; j++) \n{\n    let currentFactoryBot = factoryBots[j];\n    let currentSystemTag = currentFactoryBot.tags.system;\n\n    if (currentSystemTag == tags.system)\n    {\n        continue;\n    }\n\n    menuButton.abMenuSortOrder = currentFactoryBot.tags.abMenuSortOrder;\n    menuButton.label = currentSystemTag.substring(11);\n    menuButton.color = currentFactoryBot.tags.color;\n    menuButton.formAddress = currentFactoryBot.tags.factoryIcon;\n\n    links.menu.abCreateMenuButton(menuButton);\n}","manifestation":"🔗dca5d987-c4d8-46e4-b60c-daa7b2f4ddad","remember":"🔗e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","menu":"🔗b30c6c5d-a4f7-4266-ba38-393dc95e1ecb","abGridMenuLabel":"toolbox","abGridMenuIcon":"construction","abGridMenuSortOrder":"3","abBotMenuIcon":"construction","abBotMenuLabel":"add to toolbox","abBotMenuSortOrder":"3","abBotMenuColor":"#55E679","abGridMenuColor":"#55E679","abBotVersion":21}},"1dd596e1-8826-4257-b5d6-dc2a9a571df5":{"id":"1dd596e1-8826-4257-b5d6-dc2a9a571df5","space":"shared","tags":{"color":"#7B64FF","form":"hex","scale":1.5,"scaleZ":0.01,"onClick":"@shout(\"padMenuReset\");\n\nconfigBot.masks.menuPortal = \"padMenu\";\n\nmasks.onGridClick = `@ shout(\"padMenuReset\");`;\nmasks.padMenuReset = `@ configBot.masks.menuPortal = null;\n\nclearTagMasks(thisBot);`;\n\nconst padLocations = tags.padLocations;\nconst menuButton = {};\n\nmenuButton.space = \"tempLocal\";\nmenuButton.padMenu = true;\nmenuButton.padMenuReset = \"@ destroy(thisBot);\";\nmenuButton.menuItemStyle = {\"border-radius\":\"8px\", \"margin-top\":\"3px\"};\nmenuButton.labelAlignment = \"left\";\nmenuButton.color = tags.color;\nmenuButton.manager = getLink(thisBot);\n\nif (padLocations.length > 0)\n{\n    menuButton.formAddress = \"meeting_room\";\n    menuButton.onClick = `@ links.manager.padGoToLocation(tags.label);`;\n\n    for (let i = 0; i < padLocations.length; i++)\n    {\n        menuButton.label = padLocations[i];\n\n        create(menuButton);\n    }\n}\n\nmenuButton.labelAlignment = \"center\";\nmenuButton.label = \"    \";\nmenuButton.formAddress = \"ios_share\";\nmenuButton.onClick = `@ links.manager.padShare();`;\n\ncreate(menuButton);\n\nif (builderVersion)\n{\n    menuButton.formAddress = \"edit\";\n    menuButton.onClick = `@ links.manager.padEditMenu();`;\n\n    create(menuButton);\n}","onPointerEnter":"@ masks.scale = tags.scale + 0.1;","onPointerExit":"@ clearTagMasks(thisBot);","system":"ab.factory.pad","padGoToLocation":"@let targetLocation = that;\nlet urlCheck = false;\n\ntry \n{\n    targetLocation = new URL(that);\n\n    urlCheck = !urlCheck;\n}\ncatch (e) \n{\n\n    os.toast(\"travelling now\");\n\n    os.goToURL(\"/?ab=\" + targetLocation);\n}\n\nlet instCheck = targetLocation.searchParams.has(\"inst\");\nlet abCheck = targetLocation.searchParams.has(\"ab\");\n\nif (instCheck)\n{\n    if (abCheck)\n    {\n        os.goToURL(\"/?gridPortal=home&inst=\" + targetLocation.searchParams.get(\"inst\") + \"&ab=\" + targetLocation.searchParams.get(\"ab\"));\n    }\n    else\n    {\n        os.goToURL(\"/?gridPortal=home&inst=\" + targetLocation.searchParams.get(\"inst\"));\n    }\n    \n}\nelse \n{\n    os.toast(\"not a recognized url\");\n}","padEditMenu":"@shout(\"padMenuReset\");\n\nconfigBot.masks.menuPortal = \"padMenu\";\n\nmasks.onGridClick = `@ shout(\"padMenuReset\");`;\nmasks.padMenuReset = `@ configBot.masks.menuPortal = null;\n\nclearTagMasks(thisBot);`;\n\nconst padLocations = tags.padLocations;\nconst menuButton = {};\n\nmenuButton.space = \"tempLocal\";\nmenuButton.padMenuSortOrder = 100;\nmenuButton.padMenuReset = \"@ destroy(thisBot);\";\nmenuButton.menuItemStyle = { \"border-radius\": \"8px\", \"margin-top\": \"3px\" };\nmenuButton.labelAlignment = \"center\";\nmenuButton.color = \"#D66D5E\";\nmenuButton.manager = getLink(thisBot);\nmenuButton.label = \"    \";\nmenuButton.formAddress = \"delete_forever\";\nmenuButton.onClick = `@ links.manager.padRemoveLocations();`;\nmenuButton.optionClick = `@ if (getBot(byMod({padLocationOption: true, formAddress: \"check_box\"})))\n{\n    tags.padMenu = true;\n}\nelse\n{\n    tags.padMenu = false;\n}`;\n\nlet deleteButton = create(menuButton);\n\nmenuButton.padMenu = true;\nmenuButton.labelAlignment = \"left\";\nmenuButton.color = tags.color;\nmenuButton.deleteButton = getLink(deleteButton);\n\nif (padLocations.length > 0) \n{\n    menuButton.formAddress = \"check_box_outline_blank\";\n    menuButton.padLocationOption = true;\n    menuButton.onClick = `@ if (tags.formAddress == \"check_box_outline_blank\")\n    {\n        tags.formAddress = \"check_box\";\n    }\n    else\n    {\n        tags.formAddress = \"check_box_outline_blank\";\n    }\n    \n    links.deleteButton.optionClick(thisBot);`;\n\n    for (let i = 0; i < padLocations.length; i++) \n    {\n        menuButton.padMenuSortOrder = i;\n        menuButton.label = padLocations[i];\n\n        create(menuButton);\n    }\n}\n\nmenuButton.onClick = null;\nmenuButton.padLocationOption = null;\nmenuButton.padMenuSortOrder = -1;\nmenuButton.label = \"+\";\nmenuButton.form = \"input\";\nmenuButton.formAddress = \"meeting_room\";\nmenuButton.onSubmit = `@ if (!that)\n{\n    return;\n}\n\nlinks.manager.padAddLocation(that.text);`;\n\ncreate(menuButton);","padShare":"@shout(\"padMenuReset\");\n\nos.setClipboard(configBot.tags.url);\n\nos.toast(\"url copied to clipboard\");","padAddLocation":"@shout(\"padMenuReset\");\n\nlet newArray = tags.padLocations;\n\nnewArray.push(that);\n\ntags.padLocations = newArray;\n\nthisBot.padEditMenu();","padRemoveLocations":"@const padMenuOptions = getBots(byMod({padLocationOption: true, formAddress: \"check_box\", padMenu: true}));\nconst removeTargets = [];\n\nfor (let i = 0; i < padMenuOptions.length; i++)\n{\n    removeTargets.push(padMenuOptions[i].tags.label);\n}\n\nshout(\"padMenuReset\");\n\nconst padLocations = tags.padLocations;\n\nfor (let j = 0; j < removeTargets.length; j++)\n{\n    let targetIndex = padLocations.indexOf(removeTargets[j]);\n\n    padLocations.splice(targetIndex, 1);\n}\n\nthisBot.padEditMenu();","abBotVersion":5,"abFactory":"true","abIgnore":"true","factoryIcon":"meeting_room","listening":"false","toolManager":"🔗14e1fdac-cfd7-4e7e-bdd1-967a4085a755","onCreate":"@if (!tags.system)\n{\n    let baseArray = [];\n\n    tags.padLocations = baseArray;\n}","abMenuSortOrder":"1"}},"34c3c210-5bf1-49cf-b151-ee2d07f0e673":{"id":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","space":"shared","tags":{"system":"ab.shell.create","form":"nothing","description":"Bot used to create/manifest bots into an actual scene/portal.","abCreateBots":"@//DEV NOTE: NEED TO UNDERSTAND WHAT TO DO IF AN ARRAY IS GIVEN\n\n//checks for initial boot boolean\nlet initialBoot = that.initialBoot;\n//bots to be generated\nlet botData = that.bots;\n//where did the data come from (optional)\nlet origin = that.origin;\n//version of the data (optional)\nlet version = that.version;\n//idMap and newBots are used to manage the incoming bot data\nlet idMap = new Map();\nlet newBots = [];\n\n//this loop creates the new bots and then packages them for additional processing, while adding any needed additional tags\nfor (const property in botData)\n{\n    const newBot = botData[property];\n    const botTotal = Object.keys(botData).length;\n    const abIDOrigin = {abIDOrigin: origin};\n    const abGridFocus = links.remember.tags.abGridFocus;\n\n    if (newBot.tags) \n    {\n        if (newBot.tags.creator) \n        {\n            abIDOrigin.oldCreator = newBot.tags.creator;\n        }\n\n        let targetPosition;\n\n        try \n        {\n            if (botTotal < 2 && abGridFocus) \n            {\n                let targetDimension = abGridFocus.dimension;\n                \n                targetPosition = { [targetDimension]: true, [targetDimension + \"X\"]: abGridFocus.position.x, [targetDimension + \"Y\"]: abGridFocus.position.y };\n            }\n\n            let b = create(newBot.tags, targetPosition, abIDOrigin);\n\n            idMap.set(property, b.id);\n            newBots.push(b);\n\n            if (b.tags.creator == thisBot.id) \n            {\n                b.tags.creator = null;\n            }\n        }\n        catch (error) \n        {\n            console.log(\"invalid bot\", error);\n        }\n    }\n    else \n    {\n        console.log(\"skipped bot: \" + newBot);\n    }\n}\n\n//array of tag relationships to be preserved\nlet linkTags = [\"link\", \"creator\", \"configBot\", \"lineTo\", \"transformer\"];\n\n//this loop contains the logic for preserving the linkTags\nfor (let newBot of newBots) \n{\n    for (let tag of linkTags) \n    {\n        let value = newBot.tags[tag];\n\n        if (tag == \"creator\") \n        {\n            value = newBot.tags.oldCreator;\n            newBot.tags.oldCreator = null;\n        }\n\n        updateBotLinks(newBot, idMap);\n\n        if (value) \n        {\n            if (Array.isArray(value)) \n            {\n                let newValue = value.map(id => {\n                    return idMap.get(id) || id;\n                })\n\n                newBot.raw[tag] = newValue;\n            }\n            else \n            {\n                const newID = idMap.get(value);\n\n                if (newID) \n                {\n                    newBot.raw[tag] = newID;\n                }\n            }\n        }\n    }\n}\n\n//toasts for hatches, but only on builder\nif (configBot.tags.abSilentMode == null && !configBot.tags.ph && builderVersion == \"builder\") \n{\n    os.toast(\"hatched \" + origin + \" v\" + version);\n}\n\n//additional hatch data\nconfigBot.tags.lastEggHatched = origin;\n\n//initial boot logic\nif (initialBoot) \n{\n    let prehatch = await shout(\"onPreHatch\", { ab: origin })[0];\n\n    if (!prehatch) \n    {\n        abInstMemory.tags.baseAB = origin;\n    }\n    links.remember.tags.baseAB = origin;\n}\n\n//onEggHatch for all just hatched bots\nwhisper(newBots, \"onEggHatch\", {ab: origin, version: version});\n\n//onAbAdded for all bots in the experience\nshout(\"onAbAdded\", {ab: origin, version: version});","remember":"🔗e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","onAbAdded":"@//shout(\"onAbAdded\", {ab: origin, version: version});\n\nconsole.log(\"ab: \" + that.ab, \"version: \" + that.version);","abIgnore":"true","abBotVersion":54,"abShell":"true"}},"398801fe-4b35-4ce4-826f-23835c1b9ac5":{"id":"398801fe-4b35-4ce4-826f-23835c1b9ac5","space":"shared","tags":{"system":"ab.action.create_bot","abAction":"true","form":"nothing","description":"Creates bots.","abGridMenuAction":"@const gridInformation = links.remember.tags.abGridFocus;\nconst newBot = {};\n\nnewBot.creator = null;\nnewBot[gridInformation.dimension] = true;\nnewBot[gridInformation.dimension + \"X\"] = gridInformation.position.x;\nnewBot[gridInformation.dimension + \"Y\"] = gridInformation.position.y;\nnewBot.color = \"#7B64FF\";//links.remember.tags.abBaseColor;\n\nlet createdBot = create(newBot);\n\nshout(\"abMenuRefresh\");\n\nlinks.manifestation.abClick();\n\nlinks.manifestation.links.abBot.masks.lineTo = createdBot.id;\n\nlinks.remember.masks.abBotFocus = \"🔗\" + createdBot.id;\n\nlinks.manifestation.abClick({menu: \"bot\"});","abGridMenuLabel":"bot","abGridMenuIcon":"add_box","remember":"🔗e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","manifestation":"🔗dca5d987-c4d8-46e4-b60c-daa7b2f4ddad","abIgnore":"true","abBotVersion":31,"abGridMenuSortOrder":"1","abGridMenuColor":"#55E679"}},"3b02ac48-be96-4345-b980-530a2075d61a":{"id":"3b02ac48-be96-4345-b980-530a2075d61a","space":"shared","tags":{"home":true,"homeX":-7,"homeY":-1,"color":"#F44E3B"}},"4aaf699e-abbf-44a8-85e1-68cbb5df0e1f":{"id":"4aaf699e-abbf-44a8-85e1-68cbb5df0e1f","space":"shared","tags":{"system":"ab.interface.nugget","form":"nothing","abInterface":"true","abIgnore":"true","abBotVersion":27,"abLoadNugget":"@let nuggetName = that.nuggetName;\nlet formattedNuggetAB = \"nug_\"+nuggetName;\nlet loadedNugget = await links.search.onLookupABEggs({abID: formattedNuggetAB, abVersion: that.version, returnType: \"data\"});\n\nloadedNugget = loadedNugget.state[nuggetName].nugget;\n\nreturn loadedNugget;","abPublishNugget":"@//shout(\"abPublishNugget\", {nug: \"nugName\", data: data});  ADD EGG ID EVENTUALLY\nlet testNugget = that.data;\nlet formattedNugget = {id: that.nug, nugget: testNugget};\nlet testNuggetName = that.nug;\nlet formattedNuggetAB = \"nug_\"+testNuggetName;\n\nmasks.nuggetToPublish = formattedNuggetAB;\n\nlinks.store.abPublishAB({ab: formattedNuggetAB, target: formattedNugget});","implementNugget":"@let nuggetName = that.nugget;\nlet nuggetVersionCheck = nuggetName.indexOf(\".v\");\nlet version;\n\nif (nuggetVersionCheck != -1)\n{\n    nuggetName = nuggetName.substring(0, nuggetVersionCheck);\n\n    let versionCheck = that.nugget.substring(nuggetVersionCheck + 2);\n\n    if (isNaN(versionCheck))\n    {\n        console.log(versionCheck, \"version is not a number\");\n    }\n    else\n    {\n        version = Number(versionCheck);\n    }\n}\nconsole.log(nuggetName, version);\nlet nugData = await thisBot.abLoadNugget({nuggetName: nuggetName, version: version});\n\nif (nugData == \"abID not found\")\n{\n    os.toast(\"nugget not found\");\n}\nelse\n{\n    let targetBot = getBot(\"id\", that.bot);\n    let targetTag = targetBot.raw[that.tag].toString();\n    let targetNug = \"{\" + that.nugget + \"}\"; \n    let nugPos = targetTag.indexOf(targetNug);\n\n    deleteTagText(targetBot, that.tag, nugPos, targetNug.length);\n    insertTagText(targetBot, that.tag, nugPos, nugData);\n}","nuggetButton":"@let tagValue = that.tagValue;\nlet regex = /\\n/gi;\nlet breakCheck;\nlet breakArray = [0];\n//let createdButtons = [];\n\nwhile (breakCheck = regex.exec(tagValue))\n{\n    breakArray.push(breakCheck.index);\n}\n\nlet newNuggetButton = {};\n\nnewNuggetButton.space = \"tempLocal\";\nnewNuggetButton.form = \"codeButton\";\nnewNuggetButton.targetBot = that.bot.id;\nnewNuggetButton.targetTag = that.tag;\nnewNuggetButton.label = \"load nugget\";\nnewNuggetButton.nuggetReset = \"@ destroy(thisBot);\";\nnewNuggetButton[that.bot.id + \".\" + that.tag] = true;\nnewNuggetButton.nuggetManager = \"🔗\" + thisBot.id;\nnewNuggetButton.onClick = `@ links.nuggetManager.implementNugget({bot: tags.targetBot, nugget: tags.targetNugget, tag: tags.targetTag});\n\ndestroy(thisBot);`;\n\nfor (let nugs = 0; nugs < that.nugget.length; nugs++)\n{\n    let currentNugget = that.nugget[nugs];\n    //let buttonCheck = createdButtons.indexOf(currentNugget.nugName);\n\n    if (!currentNugget || currentNugget == undefined) //|| buttonCheck != -1\n    {\n        continue;\n    }\n\n    if (currentNugget.nugPublish)\n    {\n        newNuggetButton.onClick = `@ links.nuggetManager.packageNugget({bot: tags.targetBot, nugget: tags.targetNugget, tag: tags.targetTag});\n\n        destroy(thisBot);`;\n\n        newNuggetButton.label = \"publish \" + currentNugget.nugName + \" nugget\";\n    }\n    else\n    {\n        newNuggetButton.label = \"load \" + currentNugget.nugName + \" nugget\";\n    }\n\n    newNuggetButton.targetNugget = currentNugget.nugName;\n    newNuggetButton[that.bot.id + \".\" + that.tag + \"Start\"] = currentNugget.nugStart;\n\n    create(newNuggetButton);\n\n    //createdButtons.push(currentNugget.nugName);\n}\n\nreturn;","nuggetParse":"@const originalTagValue = that.editedBot.raw[that.editedTag];\nlet tagValue = originalTagValue;\n\nif (!tagValue) \n{\n    return;\n}\nelse if (typeof tagValue !== \"string\") \n{\n    tagValue = tagValue.toString();\n}\n\nlet initialPossibleNugPos = 0;\n\nif (initialPossibleNugPos == -1) \n{\n    return;\n}\nelse\n{\n    tagValue = tagValue.substring(initialPossibleNugPos);\n}\n\nlet possibleNugs = originalTagValue.replace(/[^{]/g, \"\").length;\nlet totalNugBreaks = originalTagValue.replace(/[^\\n]/g, \"\").length;\nlet breakLevel = 0;\nlet nugsToCheck = [];\n\nfor (let i = 0; i < possibleNugs; i++)\n{\n    let initialNugPos = tagValue.indexOf(\"{\") + 1;\n    let possibleNugEnd = tagValue.indexOf(\"}\");\n    let possibleNug = tagValue.substring(initialNugPos, possibleNugEnd);\n\n    if (possibleNug.indexOf(\" \") == -1 && /\\n/g.test(possibleNug) != true && possibleNug.length > 0 && possibleNug.indexOf(\":\") == -1)\n    {\n        let nugBreaks = tagValue.substring(0, tagValue.indexOf(\"{\"+possibleNug+\"}\")).replace(/[^\\n]/g, \"\").length;\n        let publishCheck = tagValue.substring(initialNugPos - 6, initialNugPos - 2);\n        let nugPublish = null;\n\n        if (publishCheck == \".nug\")\n        {\n            nugPublish = true;\n        }\n\n        breakLevel += nugBreaks;\n\n        nugBreaks = totalNugBreaks - (totalNugBreaks - breakLevel);\n        \n        //CHECK IF $ before nugget\n        if (tagValue.substring(initialNugPos - 2, initialNugPos - 1) != \"$\")\n        {\n            nugsToCheck.push({nugName: possibleNug, nugStart: nugBreaks + 1, nugPublish: nugPublish});\n        }\n    }\n    else\n    {\n        let nugBreaks = tagValue.substring(0, tagValue.indexOf(\"}\")).replace(/[^\\n]/g, \"\").length;\n\n        breakLevel += nugBreaks;\n\n        nugBreaks = totalNugBreaks - (totalNugBreaks - breakLevel);\n    }\n\n    tagValue = tagValue.substring(possibleNugEnd + 1);\n}\n\nthisBot.nuggetButton({ nugget: nugsToCheck, bot: that.editedBot, tag: that.editedTag, tagValue: originalTagValue});","onABPublished":"@console.log(that.ab, tags.nuggetToPublish)\n\nif (that.ab == tags.nuggetToPublish)\n{\n    os.toast(\"nugget published\");\n\n    masks.nuggetToPublish = null;\n\n    configBot.masks.abVersion = null;\n}","onAnyBotsChanged":"@if (configBot && that[0].bot.id != thisBot.id) \n{\n    if (!configBot.tags.editingBot) return; // Ignore if the configBot isn't ready yet.\n\n    const editedBotID = configBot.tags.editingBot.replace(\"🔗\", \"\");\n\n    if (!that.find(x => x.bot.id == editedBotID)) return; // If the bot changed wasn't being edited by the user ignore it.\n\n    const editedTag = configBot.tags.editingTag;\n    const editedBot = getBot(\"id\", editedBotID);\n\n    if (editedBot && editedTag) \n    {\n        shout(\"nuggetReset\");\n\n        thisBot.nuggetParse({ editedBot, editedTag });\n    }\n}","onCreate":"@tags.listening = false;\n\n//setTagMask(thisBot, \"listening\", true, \"local\");","packageNugget":"@const targetBot = getBot(\"id\", that.bot);\nconst tagText = targetBot.raw[that.tag];\n\nif (configBot.tags.cursorStartIndex || configBot.tags.cursorEndIndex)\n{\n    let startPos = configBot.tags.cursorStartIndex;\n    let endPos = configBot.tags.cursorEndIndex;\n\n    if (startPos == endPos)\n    {\n        return;\n    }\n    else if (startPos > endPos)\n    {\n        let newStartPos = endPos;\n        let newEndPos = startPos;\n\n        startPos = newStartPos;\n        endPos = newEndPos;\n    }\n\n    let data = tagText.substring(startPos, endPos + 1);\n\n    shout(\"abPublishNugget\", {nug: that.nugget, data: data});\n\n    os.toast(\"nug is publishing\", 10);\n\n    let targetNug = \".nug {\" + that.nugget + \"}\"; \n    let nugPos = targetBot.raw[that.tag].indexOf(targetNug);\n\n    deleteTagText(targetBot, that.tag, nugPos, targetNug.length);\n}\nelse\n{\n    os.toast(\"cannot read nugget to be published\")\n}","remember":"🔗e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","search":"🔗d8371444-9158-4436-8fc7-84cc91b7f525","store":"🔗76af0491-3919-4984-aa82-22c742f4263f","listening":"false"}},"5849af55-5e8a-48d6-9106-199498e9ec08":{"id":"5849af55-5e8a-48d6-9106-199498e9ec08","space":"shared","tags":{"system":"ab.action.destroy","abAction":"true","form":"nothing","abBotMenuAction":"@const targetBot = links.remember.links.abBotFocus;\n\ndestroy(targetBot);\n\nshout(\"abMenuRefresh\");\n\nlinks.manifestation.abClick();","abBotMenuLabel":"destroy","abBotMenuIcon":"delete_forever","abBotMenuColor":"#D66D5E","abBotMenuSortOrder":"100","remember":"🔗e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","manifestation":"🔗dca5d987-c4d8-46e4-b60c-daa7b2f4ddad","abIgnore":"true","abBotVersion":31}},"5a1f5853-0a29-450b-b268-4572def066dd":{"id":"5a1f5853-0a29-450b-b268-4572def066dd","space":"shared","tags":{"system":"ab.action.download","abAction":"true","abBotVersion":1,"abBotMenuAction":"@const currentBot = getBots(\"id\", links.manifestation.links.abBot.tags.lineTo);\n\nos.downloadBots(currentBot, currentBot.id);","abCoreMenuAction":"@const downloadBots = getBots(byMod({space: \"shared\", ab1Ignore: null}));\n\nos.downloadBots(downloadBots, configBot.tags.inst);","abBotMenuColor":"#55E679","abCoreMenuColor":"#55E679","form":"nothing","abBotMenuIcon":"download","abCoreMenuIcon":"download","abBotMenuLabel":"download","abCoreMenuLabel":"download","abIgnore":"true"}},"6657b865-e983-4401-9fc9-f5418d18a7f7":{"id":"6657b865-e983-4401-9fc9-f5418d18a7f7","space":"shared","tags":{"system":"ab.core.learn","abID":"learn","form":"nothing","abBoot":"@//inst mode (player or builder)\nlet instModeCheck = await os.version().playerMode;\n//check self for initial boot data\nlet initialBoot = links.remember.tags.initialBoot ? true : false;\n//check url for possible ab's to load\nlet bootFlag = configBot.tags.ab ? configBot.tags.ab : configBot.tags.autoLoad ? configBot.tags.autoLoad : configBot.tags.auxCode;\n\n//initial boot clean up if necessary\nif (initialBoot) \n{\n    let previousBots = getBots(byMod({ \"space\": \"shared\", \"abCore\": null }));\n\n    if (previousBots)\n    {\n        destroy(previousBots);\n    }\n}\n\n//initialize remember globals\nglobalThis.abInstMemory = links.remember;\nglobalThis.abRemember = links.remember;\n\n//This checks for the appropriate array of skills and initializes them\nawait thisBot.abSkillInitialization(instModeCheck);\n\n//initializing of global variables\nglobalThis.builderVersion = instModeCheck == \"builder\" ? true : false;\nglobalThis.abPublish = links.store;\nglobalThis.abStore = links.store;\nglobalThis.ab = thisBot;\n\n//populate bootflag ab\nif (initialBoot && bootFlag)\n{\n   console.log(bootFlag);\n}\n\n//builder environment setup\nif (instModeCheck == \"builder\")\n{\n    //keep ab awake\n    links.remember.tags.abAwakeState = true;\n\n    //wake up builder\n    if (initialBoot && !bootFlag)\n    {\n        links.manifestation.onGridClick({dimension: configBot.tags.gridPortal, position:{x:0,y:0}});\n\n        links.manifestation.abManifestBot({dimension: configBot.tags.gridPortal, position:{x:0,y:0}});\n\n        links.remember.tags.baseAB = uuid();\n\n        links.menu.abInitialBootMenu();\n    }\n    else if (initialBoot)\n    {\n        links.remember.tags.baseAB = bootFlag;\n    }\n}\n\n//set initial boot data\nif (initialBoot)\n{\n    links.remember.tags.initialBoot = false;\n}\n\n//pause for ab loading\nawait os.sleep(500);\n\n//initialization shout\nshout(\"onABInitialized\");","abCore":true,"abAdapt":"@//name of the skill\nconst systemID = that;\n//bootstrap url\nconst bootStrap = os.getAB1BootstrapURL()\n//constructed url\nconst skillFile = bootStrap.slice(0, bootStrap.length-7) + systemID +\".aux\";\n\n//webhook to download the skill update\ntry\n{\n    const response = await webhook({\n        method: \"GET\",\n        url: skillFile\n    });\n\n    if (response.status !== 200) {\n        console.log('[ab bootstrap] Could not download skill.');\n        return;\n    }\n\n    const updates = response.data.updates;\n    const state = await os.getInstStateFromUpdates(updates);\n    const ids = Object.keys(state);\n    \n    console.log(\"UPDATE\", updates);\n\n    await os.applyUpdatesToInst(updates);\n\n    whisper(ids, tagName, configBot.tags.inst);\n\n    //ab.log(\"ab adapt\");\n    console.log(\"ab adapt\");\n\n    return true;\n}\ncatch\n{\n    console.log('[ab bootstrap] Could not download skill.');\n}","description":"This skill is designed to handle both reconfiguration of ab and initialization.","onBotAdded":"@//initializing pause to ensure all tempLocal user bots are fully added\nconsole.log(links.remember.tags.abBuilderIdentity + \"START UP\");\n\nsetTimeout(() => thisBot.abBoot(), 500);","remember":"🔗e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","log":"@//additiona ab console/log\nlet updatedLogs;\n\nif (!tags.abLog)\n{\n    updatedLogs = that;\n}\nelse\n{\n    updatedLogs = tags.abLog + \"\\n\" + that;\n}\n\nmasks.abLog = updatedLogs;","manifestation":"🔗dca5d987-c4d8-46e4-b60c-daa7b2f4ddad","abCreateHost":"@//this function handles creating a file for join codes\nif (links.remember.tags.hostID)\n{\n    os.toast(\"code copied to clipboard\");\n\n    os.setClipboard(links.remember.tags.hostID.substring(0,3) + \"-\" + links.remember.tags.hostID.substring(3));\n\n    return;\n}\n\nlet newHostID = uuid().replaceAll(\"-\", \"\").substring(0,6);\nlet date = DateTime.now().toMillis();\nlet recordKey = await os.getData(links.remember.tags.abRecordKey, \"b207a5e4-d531-484f-a0d6-6626bef59013\", links.remember.tags.abEndpoint);\nlet recordData = await os.recordData(recordKey.data, newHostID, {url: configBot.tags.url, date: date}, links.remember.tags.abEndpoint);\n\nif (recordData.success)\n{\n    links.remember.tags.hostID = newHostID.substring(0,3) + \"-\" + newHostID.substring(3);\n\n    os.setClipboard(links.remember.tags.hostID);\n\n    that.tags.label = \"join code: \" + newHostID.substring(0,3) + \"-\" + newHostID.substring(3);\n\n    os.toast(\"host generated, code copied to clipboard: \" + newHostID);\n}\nelse\n{\n    os.toast(\"something went wrong, please try again\");\n\n    shout(\"abMenuRefresh\");\n}","abJoinHost":"@//logic for using a join code (checks for existing files)\nshout(\"abMenuRefresh\");\n\nlet joinCode = that.text.replaceAll(\"-\", \"\");\nlet recordKey = await os.getData(links.remember.tags.abRecordKey, \"b207a5e4-d531-484f-a0d6-6626bef59013\", links.remember.tags.abEndpoint);\nlet getRecord = await os.getData(recordKey.data, joinCode, links.remember.tags.abEndpoint);\n\nif (getRecord.success)\n{\n    let date = DateTime.now();\n    let createDate = DateTime.fromMillis(getRecord.data.date);\n    let difference = date.diff(createDate, \"days\").toObject();\n\n    difference = Math.floor(difference.days);\n\n    if (difference < 8)\n    {\n        os.toast(\"joining host now\");\n    \n        os.goToURL(getRecord.data.url);\n    }\n    else\n    {\n        os.toast(\"join code out of date, please generate a new join code\");\n    }\n}\nelse\n{\n    os.toast(\"code/ab invalid, please try again\");\n}","search":"🔗d8371444-9158-4436-8fc7-84cc91b7f525","abIgnore":"true","abBotVersion":59,"menu":"🔗b30c6c5d-a4f7-4266-ba38-393dc95e1ecb","abSkillInitialization":"@//Find the appropriate array and populate skills\nlet skillArray = links.remember.tags[that + \"SkillArray\"];\n\nfor (let i = 0; i < skillArray.length; i++)\n{\n    await thisBot.abAdapt(skillArray[i]);\n}\n\nreturn;"}},"a5e2eedf-cd17-4bf8-a986-dd82aa1fd858":{"id":"a5e2eedf-cd17-4bf8-a986-dd82aa1fd858","space":"shared","tags":{"color":"#622773","form":"helix","mods":"🧬{\"color\": \"#622773\"}","system":"ab.factory.mod","abFactory":"true","abIgnore":"true","listening":"false","factoryIcon":"helix","toolManager":"🔗14e1fdac-cfd7-4e7e-bdd1-967a4085a755","onClick":"@shout(\"modMenuReset\");\n\nconfigBot.masks.menuPortal = \"modMenu\";\n\nmasks.onGridClick = `@ shout(\"modMenuReset\");`;\nmasks.modMenuReset = `@ configBot.masks.menuPortal = null;\nconfigBot.masks.tagPortal = null;\n\ntagPortalBot.masks.tagPortalAnchor = null;\n\nclearTagMasks(thisBot);`;\n\nlet modMenuBot = {};\n\nmodMenuBot.space = \"tempLocal\";\nmodMenuBot.modMenu = true;\nmodMenuBot.label = \"edit mod\";\nmodMenuBot.formAddress = \"edit\";\nmodMenuBot.color = tags.color;\nmodMenuBot.modDimension = thisBot.id + \".mods\";\nmodMenuBot.modMenuReset = `@ destroy(thisBot);`;\nmodMenuBot.menuItemStyle = {\"border-radius\":\"8px\", \"margin-top\":\"3px\"};\nmodMenuBot.onClick = `@ destroy(thisBot);\n\nconfigBot.masks.tagPortal = tags.modDimension;\n\ntagPortalBot.masks.tagPortalAnchorPoint = \"top\";\n`;\n\ncreate(modMenuBot);","onDrop":"@if (that.dragBot != thisBot || that.to.bot.tags.abFactory)\n{\n    return;\n}\n\napplyMod(that.to.bot, tags.mods);\n\nlet previoiusDimension = that.from.dimension;\n\ntags[that.to.dimension] = null;\ntags[previoiusDimension] = true;\ntags[previoiusDimension + \"X\"] = that.from.x;\ntags[previoiusDimension + \"Y\"] = that.from.y;\ntags[previoiusDimension + \"Z\"] = that.from.z;","abBotVersion":15,"abMenuSortOrder":"4"}},"b1e71564-8d39-4fe2-b91b-0f105bec4fb2":{"id":"b1e71564-8d39-4fe2-b91b-0f105bec4fb2","space":"shared","tags":{"system":"ab.action.note","abAction":"true","abBotVersion":16,"abGridMenuIcon":"sticky_note_2","form":"nothing","abGridMenuLabel":"note","abIgnore":"true","manifestation":"🔗dca5d987-c4d8-46e4-b60c-daa7b2f4ddad","remember":"🔗e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","abGridMenuAction":"@const gridInformation = links.remember.tags.abGridFocus;\nconst newBot = {};\n\nnewBot.creator = null;\nnewBot[gridInformation.dimension] = true;\nnewBot[gridInformation.dimension + \"X\"] = gridInformation.position.x;\nnewBot[gridInformation.dimension + \"Y\"] = gridInformation.position.y;\n\nlet createdBot = create(tags.noteMod, newBot);\n\nshout(\"abMenuRefresh\");\n\nlinks.manifestation.abClick();\n\nlinks.manifestation.links.abBot.masks.lineTo = createdBot.id;\n\nlinks.remember.masks.abBotFocus = \"🔗\" + createdBot.id;\n\nlinks.manifestation.abClick({menu: \"bot\"});","abGridMenuSortOrder":"2","noteMod":"🧬{\n    \"abNote\": true,\n    \"scaleX\": 1,\n    \"scaleY\": 1,\n    \"scale\": 1,\n    \"orientationMode\": \"billboard\",\n    \"color\": \"#FCC400\",\n    \"maxLODThreshold\": 0.1,\n    \"onCreate\": \"@ setTimeout(() => whisper(thisBot, 'abNoteRefresh'), 25);\",\n    \"onMaxLODEnter\": \"@setTagMask(thisBot, \\\"LODState\\\", \\\"Details\\\", \\\"tempLocal\\\");\\nwhisper(thisBot, \\\"abNoteRefresh\\\");\",\n    \"onMaxLODExit\": \"@\\nsetTagMask(thisBot, \\\"LODState\\\", \\\"Note\\\", \\\"tempLocal\\\");\\nwhisper(thisBot, \\\"abNoteRefresh\\\");\\n\",\n    \"onBotChanged\": \"@\\nlet change = that.tags[0];\\n\\nif (change == \\\"Note\\\" || change == \\\"Details\\\") \\n{\\n    whisper(thisBot, \\\"abNoteRefresh\\\");\\n}\",\n    \"labelWordWrapMode\": \"breakWords\",\n    \"onClick\": \"@const state = os.getInputState(\\\"keyboard\\\", \\\"Shift\\\");\\n\\nif (state)\\n{\\n    return;\\n}\\nelse\\n{\\n    if (tags.LODState == null || tags.LODState == \\\"Note\\\") \\n    {\\n        var currentLOD = \\\"Note\\\";\\n        var textLOD = \\\"note\\\";\\n    }\\n    else \\n    {\\n        var currentLOD = \\\"Details\\\";\\n        var textLOD = \\\"details\\\";\\n    }\\n\\n    const newLabel = await os.showInput(tags[currentLOD], \\n    {\\n        title: `edit ${textLOD} text`\\n    });\\n\\n    if (currentLOD == \\\"Note\\\" && tags.Details)\\n    {\\n        setTagMask(thisBot, \\\"label\\\", \\\"+\\\" + newLabel, \\\"tempLocal\\\");\\n    }\\n    else if (currentLOD == \\\"Note\\\")\\n    {\\n        setTagMask(thisBot, \\\"label\\\", newLabel, \\\"tempLocal\\\");\\n    }\\n    else if (currentLOD == \\\"Details\\\")\\n    {\\n        setTagMask(thisBot, \\\"label\\\", \\\"*\\\" + newLabel, \\\"tempLocal\\\");\\n    }\\n    else\\n    {\\n        setTagMask(thisBot, \\\"label\\\", newLabel, \\\"tempLocal\\\");\\n    }\\n\\n    tags[currentLOD] = newLabel;\\n}\",\n    \"abNoteRefresh\": \"@function map(input, min1, max1, min2, max2) {\\n    return (input - min1) * (max2 - min2) / (max1 - min1) + min2;\\n}\\n\\nif (tags.LODState == \\\"Note\\\" || tags.LODState == null) \\n{\\n    if (tags.Details && tags.Note) \\n    {\\n        var newLabel = \\\"+\\\" + tags.Note;\\n    }\\n    else if (tags.Note) \\n    {\\n        var newLabel = tags.Note;\\n    }\\n    else if (tags.Details) \\n    {\\n        var newLabel = \\\"+\\\";\\n    }\\n    else \\n    {\\n        var newLabel = \\\" \\\";\\n    }\\n}\\nelse if (tags.LODState == \\\"Details\\\") \\n{\\n    if (tags.Details) \\n    {\\n        var newLabel = \\\"*\\\" + tags.Details;\\n    }\\n    else if (tags.Note)\\n    {\\n        var newLabel = \\\"*\\\" + tags.Note;\\n    }\\n    else\\n    {\\n        var newLabel = \\\"*\\\";\\n    }\\n}\\n\\nif (newLabel)\\n{\\n    setTagMask(thisBot, \\\"label\\\", newLabel);\\n\\n    let lengthTest = newLabel.length;\\n\\n    if(!newLabel.includes(\\\" \\\")) tags.labelFontSize = map(lengthTest, 1, 25, .7, .2) * tags.scale;\\n    else if(lengthTest < 40) tags.labelFontSize = map(lengthTest, 1, 30, .8, .3) * tags.scale;\\n    else tags.labelFontSize = null;\\n    if(tags.labelFontSize <= 0) tags.labelFontSize = .1;\\n    \\n}\",\n    \"onDestroy\": \"@ destroy(getBots('transformer', thisBot.id));\",\n    \"labelFontSize\": 0.8\n}","abGridMenuColor":"#55E679"}},"b30c6c5d-a4f7-4266-ba38-393dc95e1ecb":{"id":"b30c6c5d-a4f7-4266-ba38-393dc95e1ecb","space":"shared","tags":{"system":"ab.interface.menu","form":"nothing","description":"This skill is designed for menu stuff.","abInterface":true,"abOpenMenu":"@configBot.masks.menuPortal = \"abMenu\";\n\nlet menuType = that ? \"ab\" + that.charAt(0).toUpperCase() + that.slice(1) + \"Menu\": \"abCoreMenu\"; //set up a check to see what type of menu should be occuring [core, bot, grid, inst]\nlet menuSkills = getBots(menuType + \"Action\");\nlet maxOptions = menuType == \"inst\" ? 7 : 5;\nlet abMenuButton = {};\n\nabMenuButton.abMenu = true;\nabMenuButton.remember = tags.remember;\nabMenuButton.manifestation = tags.manifestation;\nabMenuButton.abMenuRefresh = \"@ destroy(thisBot);\";\nabMenuButton.onClick = `@ links.baseSkill.${menuType + \"Action\"}();`;\n\nfor (let i = 0; i < menuSkills.length; i++)//ADD LOGIC FOR MORE OPTIONS THAN 5 : maxOptions\n{\n    let currentSkill = menuSkills[i];\n\n    abMenuButton.baseSkill = \"🔗\" + currentSkill.id;\n    abMenuButton.label = currentSkill.tags[menuType + \"Label\"];\n    abMenuButton.formAddress = currentSkill.tags[menuType + \"Icon\"];\n    abMenuButton.onCreate = currentSkill.tags[menuType + \"OnGenerate\"];\n    abMenuButton.abMenuSortOrder = currentSkill.tags[menuType + \"SortOrder\"];\n    abMenuButton.color = currentSkill.tags[menuType + \"Color\"] ? currentSkill.tags[menuType + \"Color\"] : links.remember.tags.abBaseColor;\n\n    thisBot.abCreateMenuButton(abMenuButton);\n}\n\nthisBot.masks.onGridClick = \"@ shout('abMenuRefresh'); links.manifestation.abClick();\";","abCreateMenuButton":"@let additionalTags = that;\nlet newMenuButton = {};\n\nnewMenuButton.space = \"tempLocal\";\nnewMenuButton.color = links.remember.tags.abBaseColor;\nnewMenuButton.labelAlignment = \"left\";\nnewMenuButton.menuItemStyle = { \"border-radius\":\"8px\", \"margin-top\":\"3px\"};\n\nfor (const tag in additionalTags)\n{\n    newMenuButton[tag] = additionalTags[tag];\n}\n\nnewMenuButton = create(newMenuButton);\n\nreturn newMenuButton;","abMenuRefresh":"@configBot.masks.menuPortal = null;\n\nmasks.onGridClick = null;","remember":"🔗e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","manifestation":"🔗dca5d987-c4d8-46e4-b60c-daa7b2f4ddad","abEnvironmentMenu":"@shout(\"abMenuRefresh\");\n\nconfigBot.masks.menuPortal = \"abMenu\";\n\nlet abMenuButton = {};\n\nabMenuButton.abMenu = true;\nabMenuButton.abMenuRefresh = \"@ destroy(thisBot);\";\nabMenuButton.manifestation = tags.manifestation;\nabMenuButton.remember = tags.remember;\nabMenuButton.learn = tags.learn;\n\nfor (let i = 0; i < 12; i++)\n{\n    switch (i)\n    {\n        case 0:\n            abMenuButton.label = \"hide\";\n            abMenuButton.formAddress = \"visibility_off\";\n            abMenuButton.onClick = `@ destroy(links.manifestation.links.abBot);\n            links.manifestation.masks.abBot = null;\n            `;\n\n            break;\n        case 1:\n            abMenuButton.label = \"color\";\n            abMenuButton.formAddress = \"palette\";\n            abMenuButton.onClick = `@ os.showInputForTag(links.remember, \"abBaseColor\", {\n            type: 'color',\n            title: 'pick a color'\n            });\n            \n            destroy(links.manifestation.links.abBot);\n            links.manifestation.masks.abBot = null;\n            `;\n\n            break;\n        case 2:\n            abMenuButton.label = \"sleep\";\n            abMenuButton.formAddress = \"nights_stay\";\n            abMenuButton.onClick = `@destroy(links.manifestation.links.abBot);\n\n            links.manifestation.masks.abBot = null;\n            links.remember.tags.abAwakeState = false;\n            `;\n\n            break;\n        case 3:\n            abMenuButton.label = \"chat\";\n            abMenuButton.formAddress = \"chat\";\n            abMenuButton.onClick = `@ os.showChat();`;\n\n            break;\n        case 4:\n            abMenuButton.label = \"nuggets\";\n            abMenuButton.nugManager = tags.nugget;\n\n            if (links.nugget.tags.listening)\n            {\n                abMenuButton.onClick = \"@ shout('abMenuRefresh'); links.manifestation.abClick(); setTagMask(links.nugManager, 'listening', null);\";\n                abMenuButton.formAddress = \"check_box\";\n            }\n            else\n            {\n                abMenuButton.onClick = \"@ shout('abMenuRefresh'); links.manifestation.abClick(); setTagMask(links.nugManager, 'listening', true, 'local');\";\n                abMenuButton.formAddress = \"check_box_outline_blank\";\n            }\n\n            break;\n        case 5:\n            abMenuButton.label = \"systemPortal=true\";\n            abMenuButton.formAddress = \"settings_applications\";\n            abMenuButton.onClick = `@ configBot.tags.systemPortal = true;`;\n\n            break;\n        case 6:\n            if (!links.gpt)\n            {\n                continue;\n            }\n\n            abMenuButton.label = \"edit \" + links.remember.tags.abBuilderIdentity + \" prompt\";\n            abMenuButton.formAddress = \"edit_note\";\n            abMenuButton.gptBot = tags.gpt;\n            abMenuButton.onClick = `@ links.gptBot.editPrompt();`;\n\n            break;\n        case 7:\n            abMenuButton.label = \"grid snap\";\n            abMenuButton.formAddress = links.remember.tags.abGridSnapState ? \"check_box\" : \"check_box_outline_blank\";\n            abMenuButton.onClick = `@ links.remember.tags.abGridSnapState = !links.remember.tags.abGridSnapState;\n            \n            tags.formAddress = links.remember.tags.abGridSnapState ? \"check_box\" : \"check_box_outline_blank\";\n            `;\n\n            break;\n        case 8:\n            abMenuButton.label = \"bot snap\";\n            abMenuButton.formAddress = links.remember.tags.abBotSnapState ? \"check_box\" : \"check_box_outline_blank\";\n            abMenuButton.onClick = `@ links.remember.tags.abBotSnapState = !links.remember.tags.abBotSnapState;\n            \n            tags.formAddress = links.remember.tags.abBotSnapState ? \"check_box\" : \"check_box_outline_blank\";\n            `;\n\n            break;\n        case 9:\n            if (!links.tests)\n            {\n                continue;\n            }\n\n            abMenuButton.label = \"record test\";\n            abMenuButton.formAddress = \"science\";\n            abMenuButton.onKeyDown = \"@ \";\n            abMenuButton.onKeyUp = \"@ \";\n            abMenuButton.onClick = `@ let shiftCheck = os.getInputState(\"keyboard\", \"Shift\");\n            let currentInst = os.getCurrentInst();\n            shout('abRecordTest');\n            shout('abMenuRefresh');\n            `;\n\n            break;\n        case 10:\n            if (!links.tests)\n            {\n                continue;\n            }\n\n            abMenuButton.label = \"record trace\";\n            abMenuButton.formAddress = \"timeline\";\n            abMenuButton.onKeyDown = \"@ \";\n            abMenuButton.onKeyUp = \"@ \";\n            abMenuButton.onClick = `@ let shiftCheck = os.getInputState(\"keyboard\", \"Shift\");\n            let currentInst = os.getCurrentInst();\n            shout('abRecordTrace');\n            shout('abMenuRefresh');\n            `;\n\n            break;\n        case 11:\n            //UPDATE LABEL\n            abMenuButton.label = \"delete \" + links.remember.tags.abBuilderIdentity + \" v\" + links.remember.tags.abCoreVersion + \".\" + links.remember.tags.abCoreIteration;\n            abMenuButton.formAddress = \"delete_forever\";\n            abMenuButton.color = \"#D66D5E\";\n            abMenuButton.onClick = `@ let allBots = getBots(\"space\", \"shared\");\n\n            destroy(links.manifestation.links.abBot);\n            \n            for (let i = 0; i < allBots.length; i++)\n            {\n                if (allBots[i].tags.system)\n                {\n                    if (allBots[i].tags.system.includes(\"ab\"))\n                    {\n                        destroy(allBots[i]);\n                    }\n                }\n            }\n            `;\n\n            break;          \n    }\n\n    abMenuButton.abMenuSortOrder = i;\n\n    thisBot.abCreateMenuButton(abMenuButton);\n}\n\nthisBot.masks.onGridClick = \"@ shout('abMenuRefresh'); links.manifestation.abClick();\";\n\n// abMenuButton.label = \"collab pov\";\n// //CHECK FOR ICON\n// abMenuButton.formAddress = \"visibility_off\";\n// abMenuButton.onClick = \"@ os.toast('work in progress')\";\n\n// abMenuButton.label = \"nuggets\";\n// //CHECK FOR ICON\n// abMenuButton.formAddress = \"check_box\";\n// abMenuButton.onClick = \"@ os.toast('work in progress')\";","learn":"🔗6657b865-e983-4401-9fc9-f5418d18a7f7","gpt":"🔗ec85c1d6-9f1a-40d4-82e1-5bd680349c27","abIgnore":"true","abBotVersion":31,"abInitialBootMenu":"@configBot.masks.menuPortal = \"abInitialMenu\";\n\nmasks.abMenuRefresh = \"@ masks.onGridClick = null;\";\nmasks.onGridClick = \"@ masks.onGridClick = null; configBot.masks.menuPortal = null;\";\n\nlet menuButton = {};\n\nmenuButton.abInitialMenu = true;\nmenuButton.gridClick = \"@ destroy(thisBot);\";\nmenuButton.abMenuRefresh = \"@ destroy(thisBot);\";\nmenuButton.learn = tags.learn;\nmenuButton.manifestation = tags.manifestation;\nmenuButton.label = \"build\";\nmenuButton.formAddress = \"cube\";\nmenuButton.color = \"#908BFC\";\nmenuButton.onClick = `@ shout(\"abMenuRefresh\");\n\nlinks.manifestation.abClick();`;\n\nthisBot.abCreateMenuButton(menuButton);\n\n\nmenuButton.formAddress = \"qr_code_scanner\";\nmenuButton.form = null;\nmenuButton.label = \"scan\";\nmenuButton.color = \"#908BFC\";\nmenuButton.onClick = `@ shout(\"abMenuRefresh\");\n\nconfigBot.tags.practicePermitScan = true;\n\nos.openQRCodeScanner();`;\n\nthisBot.abCreateMenuButton(menuButton);","search":"🔗d8371444-9158-4436-8fc7-84cc91b7f525","nugget":"🔗4aaf699e-abbf-44a8-85e1-68cbb5df0e1f","tests":"🔗b83d972b-0535-4051-b589-41ceda8535f1","onPortalChanged":"@if (that.portal == \"systemPortal\" && !that.dimension && !links.tests)\n{\n    links.learn.abAdapt(\"abTests\");\n}","ask":"🔗ec85c1d6-9f1a-40d4-82e1-5bd680349c27"}},"b339c118-489a-466b-ba9f-b07a5f9b664f":{"id":"b339c118-489a-466b-ba9f-b07a5f9b664f","space":"shared","tags":{"system":"ab.action.paste","abAction":true,"form":"nothing","description":"ab skill used for copying and pasting bots.","onPaste":"@if (!builderVersion)\n{\n    return;\n}\n\nconst MACROS = [\n    {\n        test: /(?:[“”])/g,\n        replacement: (val) => '\"',\n    },\n    {\n        test: /(?:[‘’])/g,\n        replacement: (val) => \"'\",\n    },\n];\n\nlet formattedCopy = replaceMacros(that.text);\nlet copyBot = JSON.parse(formattedCopy);\nlet pastedData = !copyBot.state ? {[copyBot.id]: copyBot} : copyBot.state;\nlet dimMod = links.remember.tags.abFocusData;\n\nif (Object.keys(pastedData).length == 1 && dimMod)\n{\n    pastedData[dimMod.dimension] = true;\n    pastedData[dimMod.dimension+\"X\"] = dimMod.x;\n    pastedData[dimMod.dimension+\"Y\"] = dimMod.y;\n\n    os.toast(\"bot added to inst\");\n}\nelse\n{\n    os.toast(\"bots added to inst\");\n}\n\nab.log(\"ab paste\");\n\nlinks.create.abCreateBots({bots: pastedData});\n\nfunction replaceMacros(text) {\n    if (!text) {\n        return text;\n    }\n\n    for (let m of MACROS) {\n        text = text.replace(m.test, m.replacement);\n    }\n\n    return text;\n}","remember":"🔗e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","create":"🔗34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIgnore":"true","abBotVersion":31,"onKeyDown":"@if (!builderVersion || (!links.remember.links.abBotFocus && !links.remember.links.abMultipleBotFocus))\n{\n    return;\n}\n\nif (that.keys == \"c\")\n{\n    let metaInput = os.getInputState(\"keyboard\", \"Meta\");\n\n    if (!metaInput)\n    {\n        metaInput = os.getInputState(\"keyboard\", \"Control\");\n    }\n    \n    if (!metaInput)\n    {\n        return;\n    }\n\n    let formattedFile;\n    let state = {};\n\n    if (links.remember.links.abBotFocus)\n    {\n        let selectedBot = links.remember.links.abBotFocus;\n\n        state[selectedBot.id] = selectedBot;\n\n        ab.log(\"ab copied a bot to clipboard\");\n    }\n    else if (links.remember.links.abMultipleBotFocus)\n    {\n        let selectedBots = links.remember.links.abMultipleBotFocus;\n\n        for (let i = 0; i < selectedBots.length; i++)\n        {\n            state[selectedBots[i].id] = selectedBots[i];\n        }\n\n        ab.log(\"ab copied multiple bots to clipboard\");\n    }\n\n    let newFile = {};\n    newFile.version = 1;\n    newFile.state = state;\n\n    formattedFile = JSON.stringify(newFile);\n\n    os.setClipboard(formattedFile);\n\n    os.toast(\"bot copied to clipboard\");\n}","formatText":"@"}},"b83d972b-0535-4051-b589-41ceda8535f1":{"id":"b83d972b-0535-4051-b589-41ceda8535f1","space":"shared","tags":{"system":"ab.tests.manager","runTestCase":"@const testCase = getBot('id', that);\r\nif (!testCase) {\r\n    console.log('Test case not found!');\r\n    return;\r\n}\r\n\r\nif (testCase.tags.system) {\r\n    destroy(getBots(\r\n        byTag('__testResult', true)\r\n    ));\r\n}\r\n\r\nconst d = await os.createDebugger({\r\n    pausable: true,\r\n    allowAsynchronousScripts: true\r\n});\r\n\r\nif (typeof testCase.tags.randomSeed === 'number' || typeof testCase.tags.randomSeed === 'string') {\r\n    d.math.setRandomSeed(testCase.tags.randomSeed);\r\n}\r\nconst timeline = [];\r\nawait bot.hookupDebugger({ debug: d, timeline });\r\nawait bot.addBotsToDebugger(d);\r\n\r\nlet actionsToPerform = [];\r\nlet asyncResults = {}; \r\n\r\nfor (let event of testCase.tags.timeline) {\r\n    preprocessEvent(event);\r\n}\r\n\r\nfunction preprocessEvent(event) {\r\n    if (event.type === 'user_action') {\r\n        if ('timeline' in event) {\r\n            for (let e of event.timeline) {\r\n                preprocessEvent(e);\r\n            }\r\n        } else {\r\n            let action = event.action;\r\n            if (action.type === 'action' && 'keys' in action) {\r\n                let botIds = action.keys.map(k => {\r\n                    return d.getID(d.getBot(\r\n                        either(\r\n                            byTag('system', k),\r\n                            byTag('__key', k))\r\n                    ));\r\n                });\r\n\r\n                action = {\r\n                    ...action,\r\n                    botIds,\r\n                };\r\n                delete action.keys;\r\n                actionsToPerform.push(action);\r\n            } else if (action.type === 'async_result') {\r\n                asyncResults[action.taskId] = action;\r\n            }\r\n        }\r\n    } else if (event.type === 'script') {\r\n        for (let e of event.timeline) {\r\n            preprocessEvent(e);\r\n        }\r\n    }\r\n}\r\n\r\nlet resolve;\r\nlet reject;\r\nlet promise = new Promise((res, rej) => {\r\n    resolve = res;\r\n    reject = rej;\r\n})\r\n\r\nconst expectedTimeline = testCase.tags.timeline.slice();\r\n\r\nd.onScriptActionEnqueued(a => {\r\n    if (a.type !== 'async_result' && 'taskId' in a) {\r\n        // async task was enqueued\r\n        // send async result\r\n        let result = asyncResults[a.taskId];\r\n        if (result) {\r\n            d.performUserAction(result);\r\n        }\r\n    }\r\n});\r\n\r\nfor (let a of actionsToPerform) {\r\n    console.log('perform', a);\r\n    await d.performUserAction(a);\r\n}\r\n\r\nfor (let i = 0; i < 50; i++) {\r\n    await Promise.resolve();\r\n}\r\n\r\nconst resultTimeline = bot.compileTimeline({ timeline: timeline });\r\n\r\nconsole.log('Result', resultTimeline);\r\n\r\nlet renderedResult = thisBot.renderTimeline({ timeline: resultTimeline, name: testCase.tags.testName });\r\nlet expectedResult = thisBot.renderTimeline({ timeline: expectedTimeline, name: testCase.tags.testName });\r\n\r\nif (renderedResult.string === expectedResult.string) {\r\n    return {\r\n        success: true\r\n    };\r\n    // os.toast('Sucess!');\r\n} else {\r\n    const system = 'test-failures.' + testCase.tags.testName;\r\n    let { resultBot } = thisBot.createBotsForRenderedTimeline({\r\n        system,\r\n        result: renderedResult,\r\n        creator: testCase,\r\n        systemTag: 'testSystem'\r\n    });\r\n\r\n    let { resultBot: expectedBot } = thisBot.createBotsForRenderedTimeline({\r\n        system,\r\n        result: expectedResult,\r\n        testCase,\r\n        systemTag: 'system'\r\n    });\r\n\r\n    return {\r\n        success: false,\r\n        system: system,\r\n        diffBotId: expectedBot.id,\r\n    };\r\n}","hookupDebugger":"@const { debug: d, addKeys, timeline, noWarnMissingKeys } = that;\r\nconst botTimeline = timeline ?? [];\r\n\r\nconst actionTimelines = {};\r\nconst scriptTimelines = {};\r\n\r\nlet emittedActions = [];\r\nconst asyncRequests = new Map();\r\nlet asyncTimeline = null;\r\nlet syncCounter = 0;\r\n\r\nlet botKeys = {};\r\n\r\nfunction shouldSkipAction(a) {\r\n    const c = d.configBot;\r\n    if (!c) {\r\n        return true;\r\n    }\r\n    if (a.type !== 'action') {\r\n        if (a.type === 'update_bot') {\r\n            return true;\r\n        } else if (a.type === 'add_bot') {\r\n            return true;\r\n        } else if (a.type === 'remove_bot') {\r\n            return true;\r\n        } else if (a.type === 'async_result') {\r\n            return false;\r\n        } else if (a.type === 'async_error') {\r\n            return false;\r\n        } else if (a.type === 'apply_state') {\r\n            return true;\r\n        } else if (a.type === 'register_builtin_portal') {\r\n            return true;\r\n        } else if(a.type === 'custom_app_container_available') {\r\n            return true;\r\n        } else if (a.type === 'register_html_app' && a.appId === '_root') {\r\n            return true;\r\n        } else if (a.type === 'define_global_bot') {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction shouldSkipUpdateForBot(update) {\r\n    const b = getBot(byID(update.botId));\r\n    return (\r\n        b && (\r\n            byTag('ab')(b) || byTag('abID')(b)\r\n        )\r\n    );\r\n}\r\n\r\nd.onBeforeUserAction(a => {\r\n    if (shouldSkipAction(a)) {\r\n        return;\r\n    }\r\n    console.log('user action', a);\r\n\r\n    if (a.type === 'action') {\r\n        asyncTimeline = null;\r\n        syncCounter += 1;\r\n        addBotAction(a);\r\n    } else {\r\n        if (a.type === 'async_result') {\r\n            // the timeline that started the async request.\r\n            asyncTimeline = asyncRequests.get(a.taskId);\r\n            if (!asyncTimeline) {\r\n                console.log('async', asyncRequests, a);\r\n                throw new Error(`Async timeline not found for task! (taskId: ${a.taskId})`);\r\n            }\r\n            asyncTimeline.push({\r\n                type: 'user_action',\r\n                action: a,\r\n            });\r\n        } else {\r\n            botTimeline.push({\r\n                type: 'user_action',\r\n                action: a,\r\n            });\r\n        }\r\n    }\r\n});\r\n\r\nd.onScriptActionEnqueued(a => {\r\n    console.log('emit action', a);\r\n    console.log('call stack', d.getCallStack());\r\n    let timeline = getCurrentScriptTimeline();\r\n\r\n    if (timeline) {\r\n        timeline.push({\r\n            type: 'emitted_action',\r\n            action: a,\r\n            location: getCurrentScriptLocation() \r\n        });\r\n    }\r\n\r\n    if ('taskId' in a) {\r\n        if (!timeline) {\r\n            debugger;\r\n            throw new Error('The timeline for the script action could not be found!');\r\n        }\r\n        asyncRequests.set(a.taskId, timeline);\r\n    }\r\n});\r\n\r\nd.onAfterScriptUpdatedTag(update => {\r\n    if (shouldSkipUpdateForBot(update)) {\r\n        return;\r\n    }\r\n\r\n    console.log('update tag', update);\r\n    console.log('call stack', d.getCallStack());\r\n    let timeline = getCurrentScriptTimeline();\r\n\r\n    if (timeline) {\r\n        let { botId, ...rest } = update;\r\n\r\n        timeline.push({\r\n            type: 'update_tag',\r\n            update: {\r\n                ...rest,\r\n                botId: getBotKey(botId) ?? botId\r\n            },\r\n            location: getCurrentScriptLocation()\r\n        });\r\n    }\r\n});\r\n\r\nd.onAfterScriptUpdatedTagMask(update => {\r\n    if (shouldSkipUpdateForBot(update)) {\r\n        return;\r\n    }\r\n\r\n    console.log('update tag mask', update);\r\n    console.log('call stack', d.getCallStack());\r\n    let timeline = getCurrentScriptTimeline();\r\n\r\n    if (timeline) {\r\n        let { botId, ...rest } = update;\r\n\r\n        timeline.push({\r\n            type: 'update_tag_mask',\r\n            update: {\r\n                ...rest,\r\n                botId: getBotKey(botId) ?? botId\r\n            },\r\n            location: getCurrentScriptLocation()\r\n        });\r\n    }\r\n});\r\n\r\nfunction getCurrentScriptTimeline() {\r\n    if (!asyncTimeline) {\r\n        let currentScript = getCurrentScript();\r\n        if (currentScript) {\r\n            return getScriptTimeline(currentScript.botId, currentScript.tag, syncCounter);\r\n        }\r\n        return null;\r\n    } else {\r\n        return asyncTimeline;\r\n    }\r\n}\r\n\r\nfunction getScriptTimeline(botId, tag, syncCounter) {\r\n    const key = `${botId}.${tag}:${syncCounter}`;\r\n    let timeline = scriptTimelines[key];\r\n    if (!timeline) {\r\n        scriptTimelines[key] = timeline = [];\r\n        let actionTimeline = actionTimelines[syncCounter];\r\n\r\n        if (actionTimeline) {\r\n            const originalBotId = getOriginalBotId(botId);\r\n            actionTimeline.push({\r\n                type: 'script',\r\n                botId: getBotKey(botId),\r\n                tag: tag,\r\n                count: syncCounter,\r\n                timeline,\r\n                location: {\r\n                    botId: originalBotId,\r\n                    tag,\r\n                    line: 0,\r\n                    column: 0\r\n                }\r\n            });\r\n        }\r\n    }\r\n    return timeline;\r\n}\r\n\r\nfunction getCurrentScript() {\r\n    const callStack = d.getCallStack();\r\n    for (let i = 0; i < callStack.length; i++) {\r\n        let frame = callStack[i];\r\n        if (frame.location?.botId && frame.location?.tag) {\r\n            return {\r\n                botId: frame.location.botId,\r\n                tag: frame.location.tag\r\n            }\r\n        }\r\n    };\r\n\r\n    return null;\r\n}\r\n\r\nfunction getCurrentScriptLocation() {\r\n    const callStack = d.getCallStack();\r\n    for (let i = callStack.length - 1; i >= 0; i--) {\r\n        let frame = callStack[i];\r\n        if (frame.location?.botId && frame.location?.tag) {\r\n            const botId = getOriginalBotId(frame.location.botId);\r\n            return {\r\n                botId: botId,\r\n                tag: frame.location.tag,\r\n                line: frame.location.lineNumber,\r\n                column: frame.location.columnNumber\r\n            };\r\n        }\r\n    };\r\n\r\n    return null;\r\n}\r\n\r\nasync function addBotAction(a) {\r\n    let action;\r\n    if (a.botIds) {\r\n        let keys = [];\r\n        for (let botId of a.botIds) {\r\n            const key = getBotKey(botId);\r\n            if (!key) {\r\n                continue;\r\n            }\r\n\r\n            keys.push(key);\r\n        }\r\n\r\n        action = {\r\n            ...a,\r\n            keys\r\n        };\r\n        delete action.botIds;\r\n    } else {\r\n        action = a;\r\n    }\r\n\r\n    const timeline = actionTimelines[syncCounter] = [\r\n        {\r\n            type: 'user_action',\r\n            action: action,\r\n        }\r\n    ];\r\n    botTimeline.push({\r\n        type: 'user_action',\r\n        timeline: timeline\r\n    });\r\n}\r\n\r\nfunction getOriginalBotId(botId) {\r\n    let bot = d.getBot('id', botId);\r\n    if (!bot || !bot.tags.__originalBotId) {\r\n        return null;\r\n    }\r\n    let originalBot = getBot('id', bot.tags.__originalBotId);\r\n    if (!originalBot) {\r\n        return null;\r\n    }\r\n\r\n    return originalBot.id;\r\n}\r\n\r\nfunction getBotKey(botId) {\r\n    let bot = d.getBot('id', botId);\r\n    if (!bot || !bot.tags.__originalBotId) {\r\n        return null;\r\n    }\r\n    let originalBot = getBot('id', bot.tags.__originalBotId);\r\n    if (!originalBot) {\r\n        return null;\r\n    }\r\n    let key = bot.tags.__key ?? bot.tags.system ?? botKeys[botId];\r\n    if (!key) {\r\n        if (addKeys) {\r\n            key = botKeys[botId] = originalBot.tags.__key = uuid();\r\n        } else if (noWarnMissingKeys) {\r\n            key = originalBot.id;\r\n        } else {\r\n            console.warn(`No key could be determined for ${botId}! Set the system tag or the __key tag to enable consistent tests.`);\r\n            os.toast(`No key could be determined for ${botId}! Set the system tag or the __key tag to enable consistent tests.`);\r\n        }\r\n    }\r\n    return key;\r\n}","compileTimeline":"@let finalTimeline = [];\r\nlet hasUserAction = false;\r\nlet timeline = that.timeline;\r\n\r\nfor(let i = 0; i < timeline.length; i++) {\r\n    const event = timeline[i];\r\n\r\n    if (event.type === 'user_action') {\r\n        hasUserAction = true;\r\n\r\n        if ('timeline' in event) {\r\n            if (event.timeline.length <= 1) {\r\n                continue;\r\n            }\r\n        }\r\n    } else if (!hasUserAction) {\r\n        continue;\r\n    }\r\n\r\n    finalTimeline.push(event);\r\n}\r\n\r\nconsole.log('[debug] Timeline', timeline.slice());\r\nconsole.log('[debug] Final Timeline', finalTimeline);\r\nreturn finalTimeline;","addBotsToDebugger":"@const d = that;\r\nconst testableBots = getBots(\r\n    not(byTag('__test')),\r\n    not(byTag('ab')),\r\n    not(byTag('abID')),\r\n    not(byID(getID(thisBot))),\r\n    not(byTag('abTestTools')),\r\n    not(bySpace('bootstrap'))\r\n);\r\n\r\nif (testableBots.length <= 0) {\r\n    throw new Error('Unable to create test with no bots!');\r\n}\r\nfor (let b of testableBots) {\r\n    if (b.id === gridPortalBot.id || \r\n        b.id === configBot.id ||\r\n        b.id === miniGridPortalBot.id ||\r\n        b.id === mapPortalBot.id ||\r\n        b.id === systemPortalBot.id ||\r\n        b.id === sheetPortalBot.id ||\r\n        b.id === tagPortalBot.id ||\r\n        b.id === menuPortalBot.id ||\r\n        b.id === idePortalBot.id ||\r\n        b.id === meetPortalBot.id ||\r\n        b.id === botPortalBot.id ||\r\n        b.id === miniMapPortalBot.id ||\r\n        b.id === leftWristPortalBot.id ||\r\n        b.id === rightWristPortalBot.id) {\r\n        continue;\r\n    }\r\n\r\n    let tags = Object.keys(b.tags);\r\n\r\n    if (tags.length <= 0) {\r\n        console.log('no tags!', b);\r\n        continue;\r\n    }\r\n    await d.create(b, {\r\n        __originalBotId: b.id\r\n    });\r\n}","abID":"tests-manager","color":"#f1ff3a","onPortalChanged":"@if (that.portal === 'systemPortal') {\r\n    if (!configBot.tags.codeToolsPortal) {\r\n        configBot.masks.codeToolsPortal = 'abTestTools';\r\n\r\n        destroy(getBots(\r\n            byTag('abTestTools', true),\r\n            bySpace('tempLocal')\r\n        ));\r\n\r\n        const runTestsButton = create({\r\n            space: 'tempLocal',\r\n            abTestTools: true,\r\n            label: 'Run Tests',\r\n            onClick: `@shout(\"abRunTests\")`,\r\n        });\r\n\r\n        thisBot.masks.runTestsButton = runTestsButton.link;\r\n    }\r\n}","abRecordTest":"@const testName = await os.showInput('', {\r\n    title: 'Enter test name'\r\n});\r\n\r\nif (!testName) {\r\n    os.toast(\"You must provide a test name in order to record a test.\");\r\n    return;\r\n}\r\n\r\nconst d = await os.createDebugger({\r\n    pausable: true,\r\n    allowAsynchronousScripts: true\r\n});\r\n\r\nconst seed = math.randomInt(-2147483648, 2147483647);\r\nbot.vars.tracing = null;\r\nbot.vars.testName = testName;\r\nbot.vars.randomSeed = seed;\r\nbot.vars.debug = d;\r\nd.math.setRandomSeed(seed);\r\nbot.vars.timeline = [];\r\nawait bot.hookupDebugger({ debug: d, addKeys: true, timeline: bot.vars.timeline });\r\nawait bot.addBotsToDebugger(d);\r\n\r\nawait os.attachDebugger(d, {\r\n    tagNameMapper: {\r\n        forward: forwardMapTagName,\r\n        reverse: reverseMapTagName\r\n    },\r\n});\r\n\r\nawait os.sleep(1000);\r\n\r\nif (configBot.tags.gridPortal) {\r\n    bot.vars.originalGridPortal = configBot.tags.gridPortal;\r\n    d.configBot.tags.gridPortal = configBot.tags.gridPortal = 'test-' + configBot.tags.gridPortal;\r\n}\r\n\r\nshout(\"abSleep\", \"sleep\");\r\nshout('abReset');\r\n\r\nfunction forwardMapTagName(name) {\r\n    const builtinTags = os.listBuiltinTags();\r\n    if (builtinTags.some(t => t === name)) {\r\n        return name;\r\n    }\r\n\r\n    return 'test-' + name;\r\n}\r\n\r\nfunction reverseMapTagName(name) {\r\n    const builtinTags = os.listBuiltinTags();\r\n    if (builtinTags.some(t => t === name)) {\r\n        return name;\r\n    }\r\n\r\n    let withoutTest = name.substring('test-'.length);\r\n    return withoutTest;\r\n}\r\n\r\nawait os.registerApp('abTestingApp', thisBot);\r\nthisBot.renderTestingApp();","renderTestingApp":"@let result;\r\n\r\nif  (thisBot.vars.debug) {\r\n    if (thisBot.vars.tracing) {\r\n        result = <div>\r\n            <button onClick={() => thisBot.abStopTracing()}>Stop Tracing</button>\r\n        </div>\r\n    } else {\r\n        result = <div>\r\n            <button onClick={() => thisBot.abStopRecording()}>Stop Recording</button>\r\n        </div>\r\n    }\r\n} else {\r\n    result = <div></div>;\r\n}\r\n\r\nos.compileApp('abTestingApp', result);","abStopRecording":"@if (bot.vars.debug) {\r\n    await os.detachDebugger(bot.vars.debug);\r\n}\r\n\r\nbot.vars.debug = null;\r\nbot.vars.tracing = null;\r\n\r\nif (bot.vars.originalGridPortal) {\r\n    configBot.tags.gridPortal = bot.vars.originalGridPortal;\r\n    bot.vars.originalGridPortal = null;\r\n}\r\n\r\nconsole.log('[debug] Done!');\r\nlet finalTimeline = bot.compileTimeline({ timeline: bot.vars.timeline });\r\n\r\ncreate({\r\n    __test: true,\r\n    __testCase: true,\r\n    timeline: '🧬' + getFormattedJSON(finalTimeline.slice()),\r\n    onClick: `@shout('runTestCase', thisBot.id)`,\r\n    system: 'tests.' + bot.vars.testName,\r\n    randomSeed: bot.vars.randomSeed,\r\n    testName: bot.vars.testName\r\n});\r\n\r\nshout(\"abSleep\", \"wake\");\r\nthisBot.renderTestingApp();","abRunTests":"@const testCases = getBots(\r\n    byTag('__test', true),\r\n    byTag('__testCase', true)\r\n);\r\n\r\nlet totalCount = testCases.length;\r\nlet completedCount = 0;\r\nlet successCount = 0;\r\nlet failureCount = 0;\r\nlet promises = [];\r\nfor(let testCase of testCases) {\r\n    if (testCase.tags.skip) {\r\n        continue;\r\n    }\r\n\r\n    const promise = thisBot.runTestCase(getID(testCase)).then((result) => {\r\n        if (result.success) {\r\n            successCount += 1;\r\n        } else {\r\n            failureCount += 1;\r\n        }\r\n        completedCount += 1;\r\n        if (thisBot.links.runTestsButton) {\r\n            thisBot.links.runTestsButton.masks.label = `${completedCount}/${totalCount}`;\r\n        }\r\n\r\n        return result;\r\n    });\r\n    promises.push(promise);\r\n}\r\n\r\nconst results = await Promise.all(promises);\r\n\r\nlet success = true;\r\nlet firstUnsucessfulResult = null;\r\nfor(let result of results) {\r\n    if (result.success) {\r\n        continue;\r\n    }\r\n    success = false;\r\n    firstUnsucessfulResult = result;\r\n    break;\r\n}\r\n\r\nif (success) {\r\n    os.toast(\"Success!\");\r\n\r\n    if (thisBot.links.runTestsButton) {\r\n        thisBot.links.runTestsButton.masks.label = `✓ ${successCount}/${totalCount}`;\r\n    }\r\n\r\n    return true;\r\n} else {\r\n    configBot.tags.systemPortalDiff = 'testSystem';\r\n    configBot.tags.systemPortal = firstUnsucessfulResult.system;\r\n    configBot.tags.systemPortalPane = 'diff';\r\n    configBot.tags.systemPortalDiffBot = firstUnsucessfulResult.diffBotId;\r\n    configBot.tags.systemPortalDiffTag = 'timeline';\r\n\r\n    if (thisBot.links.runTestsButton) {\r\n        thisBot.links.runTestsButton.masks.label = `❌ ${successCount}/${totalCount}`;\r\n    }\r\n\r\n    return false;\r\n}","abRecordTrace":"@const d = await os.createDebugger({\r\n    pausable: true,\r\n    allowAsynchronousScripts: true\r\n});\r\n\r\nif (!bot.vars.traceCounter) {\r\n    bot.vars.traceCounter = 0;\r\n}\r\nbot.vars.traceCounter += 1;\r\nbot.vars.debug = d;\r\nbot.vars.tracing = true;\r\nbot.vars.timeline = [];\r\nawait bot.hookupDebugger({ debug: d, addKeys: false, timeline: bot.vars.timeline, noWarnMissingKeys: true });\r\nawait bot.addBotsToDebugger(d);\r\n\r\nawait os.attachDebugger(d, {\r\n    tagNameMapper: {\r\n        forward: forwardMapTagName,\r\n        reverse: reverseMapTagName\r\n    },\r\n});\r\n\r\nawait os.sleep(1000);\r\n\r\nif (configBot.tags.gridPortal) {\r\n    bot.vars.originalGridPortal = configBot.tags.gridPortal;\r\n    d.configBot.tags.gridPortal = configBot.tags.gridPortal = 'test-' + configBot.tags.gridPortal;\r\n}\r\n\r\nshout(\"abSleep\", \"sleep\");\r\nshout('abReset');\r\n\r\nfunction forwardMapTagName(name) {\r\n    const builtinTags = os.listBuiltinTags();\r\n    if (builtinTags.some(t => t === name)) {\r\n        return name;\r\n    }\r\n\r\n    return 'test-' + name;\r\n}\r\n\r\nfunction reverseMapTagName(name) {\r\n    const builtinTags = os.listBuiltinTags();\r\n    if (builtinTags.some(t => t === name)) {\r\n        return name;\r\n    }\r\n\r\n    let withoutTest = name.substring('test-'.length);\r\n    return withoutTest;\r\n}\r\n\r\nawait os.registerApp('abTestingApp', thisBot);\r\nthisBot.renderTestingApp();","abStopTracing":"@if (bot.vars.debug) {\r\n    await os.detachDebugger(bot.vars.debug);\r\n}\r\n\r\nbot.vars.debug = null;\r\nbot.vars.tracing = null;\r\n\r\nif (bot.vars.originalGridPortal) {\r\n    configBot.tags.gridPortal = bot.vars.originalGridPortal;\r\n    bot.vars.originalGridPortal = null;\r\n}\r\n\r\nconsole.log('[debug] Done!');\r\nlet finalTimeline = bot.compileTimeline({ timeline: bot.vars.timeline });\r\n\r\nconst traceName = 'traces.' + pad(bot.vars.traceCounter.toString());\r\nconst rendered = thisBot.renderTimeline({ timeline: finalTimeline, name: traceName });\r\nconst { resultBot } = thisBot.createBotsForRenderedTimeline({ result: rendered, system: traceName });\r\n\r\nshout(\"abSleep\", \"wake\");\r\nthisBot.renderTestingApp();\r\n\r\nos.focusOn(resultBot, {\r\n    tag: 'timeline',\r\n    portal: 'system',\r\n    lineNumber: 0,\r\n    columnNumber: 0\r\n});\r\n\r\nfunction pad(str) {\r\n\r\n    let remaining = 6 - str.length;\r\n    if (remaining > 0) {\r\n        let padded = '0'.repeat(remaining);\r\n        return padded + str;\r\n    }\r\n\r\n    // while(str.length < 6) {\r\n    //     str += '0' + str;\r\n    // }\r\n\r\n    return str;\r\n}","renderTimeline":"@class StringBuilder {\r\n    constructor(str) {\r\n        this.indent = 0;\r\n        this.markers = [];\r\n        this.str = str;\r\n        this.loc = loc(str);\r\n    }\r\n\r\n    appendLine(s) {\r\n        if (this.indent > 0) {\r\n            this.str += indent(s, this.indent);\r\n        } else {\r\n            this.str += s;\r\n        }\r\n        this.str += '\\n';\r\n        this.loc = loc(this.str);\r\n        return this;\r\n    }\r\n\r\n    append(s) {\r\n        this.str += s;\r\n        this.loc = loc(this.str);\r\n        return this;\r\n    }\r\n}\r\n\r\nfunction loc(str) {\r\n    const lines = str.split('\\n');\r\n    const line = lines.length;\r\n    const col = lines[lines.length - 1].length;\r\n    return {\r\n        line,\r\n        col\r\n    };\r\n}\r\n\r\nfunction renderTimeline(timeline, name) {\r\n    let builder = new StringBuilder('@');\r\n    builder.appendLine('// Note: this is a visualization of the test timeline.');\r\n    builder.appendLine('// It does not contain working code.\\n');\r\n    builder.appendLine(`start('${name}')`);\r\n    for(let event of timeline) {\r\n        renderEvent(event, builder);\r\n    }\r\n\r\n    console.log(builder.str);\r\n    builder.appendLine('end()');\r\n    return {\r\n        string: builder.str,\r\n        markers: builder.markers\r\n    };\r\n}\r\n\r\nfunction renderEvent(event, builder) {\r\n    console.log('render', event);\r\n    if (event.type === 'user_action') {\r\n        renderUserAction(event, builder);\r\n    } else if (event.type === 'emitted_action') {\r\n        renderEmittedAction(event, builder);\r\n    } else if (event.type === 'check') {\r\n        builder.appendLine(`check: ${getFormattedJSON(event.diff)}`);\r\n    } else if (event.type === 'update_tag') {\r\n        renderUpdateTag(event, builder);\r\n    } else if (event.type === 'update_tag_mask') {\r\n        renderUpdateTagMask(event, builder);\r\n    } else if (event.type === 'script') {\r\n        renderScript(event, builder);\r\n    }\r\n}\r\n\r\nfunction renderShout(event, builder) {\r\n    builder.appendLine(`// @${event.action.eventName}`);\r\n    if (event.action.keys.length > 0) {\r\n        builder.appendLine(`whisper.${event.action.eventName}('${event.action.keys.join(',')}')`);\r\n    } else {\r\n        builder.appendLine(`shout.${event.action.eventName}()`);\r\n    }\r\n}\r\n\r\nfunction renderEmittedAction(event, builder) {\r\n    let prefix = '';\r\n    if ('taskId' in event.action) {\r\n        prefix = `\\$${event.action.taskId}: `;\r\n    }\r\n    let { taskId, type, ...rest } = event.action;\r\n\r\n    if (event.location) {\r\n        builder.markers.push({\r\n            line: builder.loc.line,\r\n            label: 'Go to action',\r\n            location: event.location\r\n        });\r\n    }\r\n\r\n    builder.appendLine(`${prefix}${type}(${getFormattedJSON(rest)})`);\r\n}\r\n\r\nfunction renderUpdateTag(event, builder) {\r\n    if (event.location) {\r\n        builder.markers.push({\r\n            line: builder.loc.line,\r\n            label: 'Go to Tag Update',\r\n            location: event.location\r\n        });\r\n    }\r\n\r\n    builder.appendLine(`updateTag(${event.update.tag}, ${getFormattedJSON(event.update.newValue)})`);\r\n}\r\n\r\nfunction renderUpdateTagMask(event, builder) {\r\n    if (event.location) {\r\n        builder.markers.push({\r\n            line: builder.loc.line,\r\n            label: 'Go to Tag Mask Update',\r\n            location: event.location\r\n        });\r\n    }\r\n\r\n    builder.appendLine(`updateTagMask(${event.update.tag}, ${event.update.space}, ${getFormattedJSON(event.update.newValue)})`);\r\n}\r\n\r\nfunction renderScript(event, builder) {\r\n    if (event.location) {\r\n        builder.markers.push({\r\n            line: builder.loc.line,\r\n            label: 'Go to Script',\r\n            location: event.location\r\n        });\r\n    }\r\n\r\n    builder.appendLine(`run_script('${event.botId}', '${event.tag}', () => {`);\r\n    builder.indent += 4;\r\n    for (let e of event.timeline) {\r\n        renderEvent(e, builder);\r\n    }\r\n    builder.indent -= 4;\r\n    builder.appendLine('\\n})');\r\n}\r\n\r\nfunction renderUserAction(event, builder) {\r\n    if ('timeline' in event) {\r\n        for (let e of event.timeline) {\r\n            renderEvent(e, builder);\r\n        }\r\n    } else if (event.action.type === 'action') {\r\n        renderShout(event, builder);\r\n    } else if (event.action.type === 'async_result') {\r\n        let formatted = getFormattedJSON(event.action.result);\r\n        let commented = formatted.split('\\n').map(line => `// ${line}`).join('\\n');\r\n\r\n        builder.appendLine(`${commented} -> \\$${event.action.taskId}`);\r\n    }\r\n}\r\n\r\nfunction indent(str, level) {\r\n    let lines = str.split('\\n');\r\n    let indentString = ' '.repeat(level);\r\n    let indented = lines.map(l => l.length > 0 ? indentString + l : l);\r\n    return indented.join('\\n');\r\n}\r\n\r\nconst { timeline, name } = that;\r\n\r\nreturn renderTimeline(timeline, name);","createBotsForRenderedTimeline":"@const { system, result, creator, systemTag } = that;\r\n\r\n// const system = systemPrefix + testCase.tags.testName;\r\n\r\nlet resultBot = create({\r\n    space: 'tempLocal',\r\n    creator: creator?.id,\r\n    __test: true,\r\n    __testResult: true,\r\n    timeline: result.string,\r\n    [systemTag ?? 'system']: system\r\n});\r\n\r\nconst markerMod = {\r\n    space: 'tempLocal',\r\n    creator: resultBot.id,\r\n    __test: true,\r\n    __testResult: true,\r\n    form: 'codeButton',\r\n    onClick: `@os.focusOn(bot.tags.location.botId, { portal: 'system', tag: bot.tags.location.tag, lineNumber: bot.tags.location.line, columnNumber: bot.tags.location.column })`\r\n};\r\n\r\nfor (let marker of result.markers) {\r\n    create(markerMod, {\r\n        [`${resultBot.id}.timeline`]: true,\r\n        [`${resultBot.id}.timelineStart`]: marker.line,\r\n        label: marker.label,\r\n        location: marker.location,\r\n    });\r\n}\r\n\r\nreturn {\r\n    resultBot\r\n};","abTests":"true","form":"nothing","abBotVersion":2,"abIgnore":"true","ab1BotVersion":null}},"c44ebc7f-3df7-4e8e-9781-14e2ce8e34c8":{"id":"c44ebc7f-3df7-4e8e-9781-14e2ce8e34c8","space":"shared","tags":{"factoryIcon":"inventory_2","color":"#908BFC","abBotVersion":20,"form":"circle","scale":2,"toolManager":"🔗14e1fdac-cfd7-4e7e-bdd1-967a4085a755","scaleZ":"0.1","system":"ab.factory.botStore","onDrop":"@if (that.dragBot == thisBot || that.dragBot.tags.space != \"shared\")\n{\n    return;\n}\n\nthisBot[tags.storeMode + \"OnDrop\"](that);","botStoreRejectBot":"@that.dragBot.tags[that.to.dimension] = null;\nthat.dragBot.tags[that.from.dimension] = true;\nthat.dragBot.tags[that.from.dimension+\"X\"] = that.from.x;\nthat.dragBot.tags[that.from.dimension+\"Y\"] = that.from.y;\nthat.dragBot.tags[that.from.dimension+\"Z\"] = that.from.z;","storeMode":"unlimited","unlimitedOnDrop":"@if (tags.template)\n{\n    thisBot.botStoreRejectBot(that);\n\n    return;\n}\n\nthisBot.addTemplate(that);","limitedOnDrop":"@if ((tags.botStoreID && that.dragBot.tags.botStoreID != tags.botStoreID) || tags.maxCount == tags.label)\n{\n    thisBot.botStoreRejectBot(that);\n\n    return;\n}\n\ntags.label++;\n\nif (tags.template)\n{\n    destroy(that.dragBot);\n}\nelse\n{\n    thisBot.addTemplate(that);\n}","addTemplate":"@tags.template = getLink(that.dragBot);\n\nthat.dragBot.tags.listening = false;\nthat.dragBot.tags.pointable = false;\nthat.dragBot.tags.transformer = thisBot.id;\nthat.dragBot.tags.creator = thisBot.id;\nthat.dragBot.tags.transformer = thisBot.id;\nthat.dragBot.tags[that.to.dimension + \"X\"] = 0;\nthat.dragBot.tags[that.to.dimension + \"Y\"] = 0;\nthat.dragBot.tags[that.to.dimension + \"Z\"] = 5;\nthat.dragBot.tags.scale = that.dragBot.tags.scale ? that.dragBot.tags.scale / 2 : 0.5;\nthat.dragBot.tags.scaleX = that.dragBot.tags.scaleX ? that.dragBot.tags.scaleX / 2 : 1;\nthat.dragBot.tags.scaleY = that.dragBot.tags.scaleY ? that.dragBot.tags.scaleY / 2 : 1;\nthat.dragBot.tags.scaleZ = that.dragBot.tags.scaleZ ? that.dragBot.tags.scaleZ * 10 : 10;\n\nif (tags.storeMode == \"limited\")\n{\n    let newStoreID = uuid();\n\n    tags.botStoreID = newStoreID;\n\n    that.dragBot.tags.botStoreID = newStoreID;\n}\n\nlet hitBox = {};\n\nhitBox.transformer = thisBot.id;\nhitBox.color = \"clear\";\nhitBox.draggable = false;\nhitBox.manager = getLink(thisBot);\nhitBox.onDrag = `@ links.manager.templateDrag(that);`;\nhitBox.scale = links.template.tags.scale;\nhitBox.scaleX = links.template.tags.scaleX;\nhitBox.scaleY = links.template.tags.scaleY;\nhitBox.scaleZ = links.template.tags.scaleZ;\nhitBox[that.to.dimension] = true;\nhitBox[that.to.dimension + \"X\"] = 0;\nhitBox[that.to.dimension + \"Y\"] = 0;\nhitBox[that.to.dimension + \"Z\"] = 5;\n\nlet newHitbox = create(hitBox);\n\nlinks.hitBox = getLink(newHitbox);\n\nthisBot.initiateBotStoreAnimation();","onClick":"@shout(\"botStoreMenuReset\");\n\nconfigBot.masks.menuPortal = \"botStoreMenu\";\n\nmasks.onGridClick = `@ shout(\"botStoreMenuReset\");`;\nmasks.botStoreMenuReset = `@ configBot.masks.menuPortal = null;\n\nclearTagMasks(thisBot);`;\n\nlet menuButton = {};\n\nmenuButton.space = \"tempLocal\";\nmenuButton.botStoreMenu = true;\nmenuButton.botStoreMenuReset = \"@ destroy(thisBot);\";\nmenuButton.menuItemStyle = {\"border-radius\":\"8px\", \"margin-top\":\"3px\"};\nmenuButton.labelAlignment = \"left\";\nmenuButton.color = tags.color;\nmenuButton.manager = getLink(thisBot);\nmenuButton.onClick = `@ shout(\"botStoreMenuReset\");\n    \nlinks.manager.changeStoreState();`;\n\nif (tags.storeMode == \"unlimited\")\n{\n    menuButton.formAddress = \"inventory\";\n    menuButton.label = \"change to limited\";\n\n    create(menuButton);\n}\nelse\n{\n    menuButton.formAddress = \"file_copy\";\n    menuButton.label = \"change to unlimited\";\n\n    create(menuButton);\n\n    menuButton.label = \"    \";\n    menuButton.labelAlignment = \"center\";\n    menuButton.onClick = `@ links.manager.tags.templateLock = !links.manager.tags.templateLock\n    \n    if (links.manager.tags.templateLock)\n    {\n        tags.formAddress = \"lock\";\n    }\n    else\n    {\n        tags.formAddress = \"lock_open\";\n    }`;\n\n    if (tags.templateLock)\n    {\n        menuButton.formAddress = \"lock\";\n    }\n    else\n    {\n        menuButton.formAddress = \"lock_open\";\n    }\n\n    create(menuButton);\n}\n\n","templateDrag":"@if (tags.storeMode == \"limited\")\n{\n    if (tags.label == 0)\n    {\n        return;\n    }\n}\n\nlet newBot = getMod(links.template);\n\nnewBot[that.from.dimension] = true;\nnewBot[that.from.dimension + \"X\"] = tags[that.from.dimension + \"X\"];\nnewBot[that.from.dimension + \"Y\"] = tags[that.from.dimension + \"Y\"];\nnewBot[that.from.dimension + \"Z\"] = 0;\nnewBot.listening = null;\nnewBot.pointable = null;\nnewBot.transformer = null;\nnewBot.creator = null;\nnewBot.transformer = null;\nnewBot.scale = newBot.scale == 0.5 ? null : newBot.scale * 2;\nnewBot.scaleX = newBot.scaleX == 1 ? null : newBot.scaleX * 2;\nnewBot.scaleY = newBot.scaleY == 1 ? null : newBot.scaleY * 2;\nnewBot.scaleZ = newBot.scaleZ == 10 ? null : newBot.scaleZ / 10;\nnewBot.botStoreID = tags.botStoreID;\n\nlet createdBot = create(newBot);\n\nos.replaceDragBot(createdBot);\n\nif (tags.storeMode == \"limited\")\n{\n    thisBot.reduceLimitedCount();\n}","reduceLimitedCount":"@tags.label--;\n\nif (tags.label == 0 && !tags.templateLock)\n{\n    clearInterval(tags.storeInterval);\n\n    destroy(links.template);\n    destroy(links.hitBox);\n\n    tags.template = null;\n    tags.hitBox = null;\n    tags.botStoreID = null;\n    masks.storeInterval = null;\n}","abFactory":"true","abIgnore":"true","listening":"false","changeStoreState":"@if (tags.storeMode == \"unlimited\")\n{\n    tags.storeMode = \"limited\";\n\n    const maxCount = await os.showInput(1, {\n        title: 'choose max'\n    });\n\n    if (!maxCount)\n    {\n        maxCount = 1;\n    }\n\n    tags.maxCount = maxCount;\n\n    if (tags.template)\n    {\n        let newStoreID = uuid();\n\n        tags.botStoreID = newStoreID;\n\n        links.template.tags.botStoreID = newStoreID;\n\n        tags.label = 1;\n    }\n    else\n    {\n        tags.label = 0;\n    }\n}\nelse\n{\n    tags.storeMode = \"unlimited\";\n\n    tags.label = null;\n    tags.maxCount = null;\n    tags.templateLock = null;\n    tags.botStoreID = null;\n}","initiateBotStoreAnimation":"@if (!tags.storeInterval)\n{\n    thisBot.animateBotStore();\n\n    masks.storeInterval = setInterval(() => thisBot.animateBotStore(), 2000);\n}","animateBotStore":"@let rotZ = configBot.tags.gridPortal + \"RotationZ\";\nlet targetRotation = 360 * Math.PI/180;\n\nawait animateTag(links.template, rotZ, {\n    fromValue: 0,\n    toValue: targetRotation,\n    easing:{\n        mode: \"inout\",\n        type: \"linear\"\n    },\n    duration: 2\n}).catch(e => {});","onInstStreaming":"@if (tags.template)\n{\n    thisBot.initiateBotStoreAnimation();\n}","onDestroy":"@clearInterval(tags.storeInterval);","abMenuSortOrder":"5"}},"c68c5b82-c0a7-4a5a-9104-5dd8e32ae4e2":{"id":"c68c5b82-c0a7-4a5a-9104-5dd8e32ae4e2","space":"shared","tags":{"system":"ab.action.open_sheet","description":"Skill to open sheet.","abAction":"true","form":"nothing","abCoreMenuAction":"@const currentInst = os.getCurrentInst();\nconst currentDim = links.remember.tags.abActiveDimension;\nconst state = os.getInputState(\"keyboard\", \"Shift\");\n\nif (state) \n{\n    os.openURL(`/?inst=${currentInst}&sheetPortal=${currentDim}`);\n}\nelse\n{\n    configBot.tags.sheetPortal = currentDim;\n}\n\nab.log(\"ab open dimension sheet\");","remember":"🔗e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","abCoreMenuLabel":"open sheet","abBotMenuAction":"@const currentInst = os.getCurrentInst();\nconst currentDim = links.manifestation.links.abBot.tags.lineTo;\nconst state = os.getInputState(\"keyboard\", \"Shift\");\n\nif (state) \n{\n    os.openURL(`/?inst=${currentInst}&sheetPortal=${currentDim}`);\n}\nelse\n{\n    configBot.tags.sheetPortal = currentDim;\n}\n\nab.log(\"ab open bot sheet\");","abBotMenuLabel":"open bot sheet","manifestation":"🔗dca5d987-c4d8-46e4-b60c-daa7b2f4ddad","abBotMenuIcon":"table_view","abCoreMenuIcon":"table_view","abBotMenuSortOrder":"1","abIgnore":"true","abBotVersion":31,"abBotMenuColor":"#55E679","abCoreMenuColor":"#55E679","abMultipleBotMenuAction":"@const currentInst = os.getCurrentInst();\nconst currentDim = \"abMultipleSelect\";\n\nconfigBot.tags.sheetPortal = currentDim;\n\nsetTagMask(links.remember.links.abMultipleBotFocus, currentDim, true, \"tempLocal\");\n\nmasks.currentSheetBots = links.remember.tags.abMultipleBotFocus;\nmasks.onPortalChanged = `@ if (that.dimension != \"abMultipleSelect\" && that.portal == \"sheetPortal\")\n{\n    clearTagMasks(links.currentSheetBots);\n\n    clearTagMasks(thisBot);\n} `;\n\nab.log(\"ab open multiple select sheet\");","abMultipleBotMenuLabel":"open multiple select sheet","abMultipleBotMenuColor":"#55E679","abMultipleBotMenuIcon":"table_view","abCoreMenuOnGenerate":"@let currentDim = links.remember.tags.abActiveDimension;\n\ntags.label = \"sheetPortal=\" + currentDim;\n\ntags.onKeyDown = `@ if(that.keys == \"Shift\"){masks.label = tags.label + \" in new tab\";}`;\ntags.onKeyUp = `@ if(that.keys == \"Shift\"){masks.label = null;}`;","abBotMenuOnGenerate":"@let selectedBot = links.manifestation.links.abBot.tags.lineTo;\n\ntags.label = \"sheetPortal=\" + selectedBot.substring(0, 4);\n\ntags.onKeyDown = `@ if(that.keys == \"Shift\"){masks.label = tags.label + \" in new tab\";}`;\ntags.onKeyUp = `@ if(that.keys == \"Shift\"){masks.label = null;}`;"}},"d140204c-55c7-4ec3-9354-93ae7626a836":{"id":"d140204c-55c7-4ec3-9354-93ae7626a836","space":"shared","tags":{"scaleZ":0.01,"scale":0.61,"color":"gray","strokeColor":"#5E5880","lineColor":"#5E5880","duration":1,"easingType":"linear","easingMode":"inout","lineStyle":"line","system":"ab.factory.track","abFactory":"true","abIgnore":"true","toolManager":"🔗14e1fdac-cfd7-4e7e-bdd1-967a4085a755","factoryIcon":"timeline","abBotVersion":15,"onCreate":"@tags.color = \"clear\";\n\nif (!tags.lineTo)\n{\n    thisBot.addTrackNode({dimension: configBot.tags.gridPortal});\n}","addTrackNode":"@let botMod = getMod(thisBot);\n\nbotMod[that.dimension + \"Y\"] = botMod[that.dimension + \"Y\"] - 3;\n\nbotMod.lineTo = thisBot.id;\nbotMod.creator = thisBot.id;\n\nlet node2 = create(botMod);\n\ntags.lineTo = node2.id;\ntags.creator = node2.id;\n\nlet node3 = create(botMod);\n\nbotMod[that.dimension + \"X\"] = botMod[that.dimension + \"X\"] + 3;\n\nlet node4 = create(botMod);\n\nnode3.tags.lineTo = node4.id;\nnode3.tags.creator = node4.id;\nnode4.tags.lineTo = node3.id;\nnode4.tags.creator = node3.id;\n\nlet node5 = create(botMod);\n\nbotMod[that.dimension + \"Y\"] = botMod[that.dimension + \"Y\"] - 3;\n\nlet node6 = create(botMod);\n\nnode5.tags.lineTo = node6.id;\nnode5.tags.creator = node6.id;\nnode6.tags.lineTo = node5.id;\nnode6.tags.creator = node5.id;","abTrackNode":"true","listening":"false","onDrop":"@if (that.dragBot.tags.abTrackNode)\n{\n    tags[configBot.tags.gridPortal + \"X\"] = Math.round(tags[configBot.tags.gridPortal + \"X\"]);\n    tags[configBot.tags.gridPortal + \"Y\"] = Math.round(tags[configBot.tags.gridPortal + \"Y\"]);\n\n    return;\n}\nelse if (that.dragBot.tags.factoryIcon == \"helix\")\n{\n    thisBot.applyModToTrackNode(that);\n\n    that.dragBot.tags[that.from.dimension + \"X\"] = that.from.x;\n    that.dragBot.tags[that.from.dimension + \"Y\"] = that.from.y;\n\n    return;\n}\n\nthat.dragBot.masks.onDrag = \"@ clearTimeout(tags.trackTimeout); clearAnimations(thisBot);\";\n\nthisBot.animateTrack({animatedBot: that.dragBot, targetNode: getBot(\"id\", tags.lineTo)});","animateTrack":"@let currentDim = configBot.tags.mapPortal ? configBot.tags.mapPortal : configBot.tags.gridPortal;\nlet animatedBot = that.animatedBot;\nlet nextNode = that.targetNode;\nlet originNode = thisBot;\n\nif (nextNode.id == thisBot.id)\n{\n    let nodeStack = getBots(byMod({abTrackNode: true, [currentDim]: true, [currentDim + \"X\"]: tags[currentDim + \"X\"], [currentDim + \"Y\"]: tags[currentDim + \"Y\"]}));\n\n    if (nodeStack.length >= 3)\n    {\n        originNode = nodeStack[math.randomInt(0, nodeStack.length)];\n\n        nextNode = getBot(\"id\", originNode.tags.lineTo);\n    }\n    else if (nodeStack.length > 1)\n    {\n        for (let i = 0; i < nodeStack.length; i++)\n        {\n            if (nodeStack[i].id != thisBot.id)\n            {\n                originNode = nodeStack[i];\n\n                nextNode = getBot(\"id\", originNode.tags.lineTo);\n\n                break;\n            }\n        }\n    }\n    else\n    {\n        nextNode = getBot(\"id\", tags.lineTo);\n    }\n}\n\nanimatedBot.masks.trackTimeout = setTimeout(()=> whisper(nextNode, \"animateTrack\", {animatedBot: animatedBot, targetNode: nextNode}), tags.duration * 1000);\n\nif (originNode.tags.mods)\n{\n    applyMod(animatedBot, originNode.tags.mods);\n}\n\nawait animateTag(animatedBot, {\n    fromValue: {\n        [currentDim + \"X\"]: originNode.tags[currentDim + \"X\"],\n        [currentDim + \"Y\"]: originNode.tags[currentDim + \"Y\"]\n    },\n    toValue: {\n        [currentDim + \"X\"]: nextNode.tags[currentDim + \"X\"],\n        [currentDim + \"Y\"]: nextNode.tags[currentDim + \"Y\"]\n    },\n    duration: tags.duration,\n    easing:{\n        type: tags.easingType,\n        mode: tags.easingMode\n    },\n    tagMaskSpace: \"tempLocal\"\n}).catch(e => {});","onClick":"@shout(\"abTrackMenuReset\");\n\nconst menuType = that.menuType ? that.menuType : \"base\";\nconst menuTag = tags[menuType + \"ABTrackMenu\"];\n\nconfigBot.masks.menuPortal = \"abTrackMenu\";\n\nmasks.onGridClick = `@ shout(\"abTrackMenuReset\");`;\nmasks.abTrackMenuReset = `@ configBot.masks.menuPortal = null;\n\nclearTagMasks(thisBot);`;\n\nlet menuButton = {};\n\nmenuButton.space = \"tempLocal\";\nmenuButton.abTrackMenu = true;\nmenuButton.abTrackMenuReset = \"@ destroy(thisBot);\";\nmenuButton.menuItemStyle = {\"border-radius\":\"8px\", \"margin-top\":\"3px\"};\nmenuButton.labelAlignment = \"left\";\nmenuButton.labelColor = \"#ffffff\";\nmenuButton.color = tags.strokeColor;\nmenuButton.manager = getLink(thisBot);\n\nfor (let i = 0; i < tags[menuType + \"ABTrackMenu\"].length; i++)\n{\n    create(menuButton, tags[menuType + \"ABTrackMenu\"][i]);\n}\n\nif (tags.mods)\n{\n    menuButton.label = \"remove mod\";\n    menuButton.formAddress = \"helix\";\n    menuButton.onClick = `@ links.manager.tags.mods = null;\n    links.manager.tags.color = \"clear\";\n    links.manager.tags.form = null;\n    \n    shout('abTrackMenuReset');`;\n\n    create(menuButton);\n}","baseABTrackMenu":"🧬[{\"onClick\": \"@ links.manager.updateTrackDuration();\", \"formAddress\": \"av_timer\", \"label\": \"duration\"},\n{\"onClick\": \"@ links.manager.onClick({menuType: 'easing'});\", \"formAddress\": \"trending_flat\", \"label\": \"easing type\"},\n{\"onClick\": \"@ links.manager.onClick({menuType: 'mode'});\", \"formAddress\": \"trending_up\", \"label\": \"easing mode\"}]","updateTrackDuration":"@shout(\"abTrackMenuReset\");\n\nlet input = await os.showInput(tags.duration, {\n    title: \"duration\"\n});\n\nif (input && !isNaN(input))\n{\n    tags.duration = input;\n}","easingABTrackMenu":"🧬[{\"onClick\": \"@ links.manager.tags.easingType = tags.label; shout('abTrackMenuReset');\", \"formAddress\": \"arrow_right\", \"label\": \"linear\"},\n{\"onClick\": \"@ links.manager.tags.easingType = tags.label; shout('abTrackMenuReset');\", \"formAddress\": \"arrow_right\", \"label\": \"quadratic\"},\n{\"onClick\": \"@ links.manager.tags.easingType = tags.label; shout('abTrackMenuReset');\", \"formAddress\": \"arrow_right\", \"label\": \"cubic\"},\n{\"onClick\": \"@ links.manager.tags.easingType = tags.label; shout('abTrackMenuReset');\", \"formAddress\": \"arrow_right\", \"label\": \"quartic\"},\n{\"onClick\": \"@ links.manager.tags.easingType = tags.label; shout('abTrackMenuReset');\", \"formAddress\": \"arrow_right\", \"label\": \"quintic\"},\n{\"onClick\": \"@ links.manager.tags.easingType = tags.label; shout('abTrackMenuReset');\", \"formAddress\": \"arrow_right\", \"label\": \"sinusoidal\"},\n{\"onClick\": \"@ links.manager.tags.easingType = tags.label; shout('abTrackMenuReset');\", \"formAddress\": \"arrow_right\", \"label\": \"exponential\"},\n{\"onClick\": \"@ links.manager.tags.easingType = tags.label; shout('abTrackMenuReset');\", \"formAddress\": \"arrow_right\", \"label\": \"circular\"},\n{\"onClick\": \"@ links.manager.tags.easingType = tags.label; shout('abTrackMenuReset');\", \"formAddress\": \"arrow_right\", \"label\": \"elastic\"}]","modeABTrackMenu":"🧬[{\"onClick\": \"@ links.manager.tags.easingMode = tags.label; shout('abTrackMenuReset');\", \"formAddress\": \"arrow_right\", \"label\": \"in\"},\n{\"onClick\": \"@ links.manager.tags.easingMode = tags.label; shout('abTrackMenuReset');\", \"formAddress\": \"arrow_right\", \"label\": \"out\"},\n{\"onClick\": \"@ links.manager.tags.easingMode = tags.label; shout('abTrackMenuReset');\", \"formAddress\": \"arrow_right\", \"label\": \"inout\"}]","applyModToTrackNode":"@let botMod = that.dragBot.tags.mods;\n\ntags.mods = botMod;\ntags.color = tags.strokeColor;\ntags.form = \"sprite\";\ntags.formAddress = \"https://builder-ltm-files.s3.amazonaws.com/b6352edb88598a1969a648f7dd6d418233ef1159bd78b737cf20a3da5405d1c4.png\";","abMenuSortOrder":"2"}},"dca5d987-c4d8-46e4-b60c-daa7b2f4ddad":{"id":"dca5d987-c4d8-46e4-b60c-daa7b2f4ddad","space":"shared","tags":{"system":"ab.interface.manifestation","form":"nothing","abInterface":true,"description":"This skill controls the actual bot for the ab interface.","learn":"🔗6657b865-e983-4401-9fc9-f5418d18a7f7","onPortalChanged":"@if (!links.remember.tags.abAwakeState || that.portal == \"tagPortal\")\n{\n    return;\n}\n\nlet portalArray = [\"miniGridPortal\", \"gridPortal\", \"mapPortal\", \"miniMapPortal\", \"leftWristPortal\", \"rightWristPortal\"];\n\nif (portalArray.indexOf(that.portal) != -1 && that.dimension)\n{\n    thisBot.onGridClick({dimension: configBot.tags.gridPortal, position:{x:0,y:0}});\n\n    thisBot.abManifestBot({dimension: that.dimension, position:{x:0,y:0}});\n}\nelse if (portalArray.indexOf(that.portal) == -1 && !that.dimension && that.portal != \"menuPortal\")\n{\n    let summonDimension = configBot.tags.mapPortal ? configBot.tags.mapPortal : configBot.tags.gridPortal;\n\n    thisBot.abManifestBot({dimension: summonDimension, position:{x:0,y:0}});\n}\nelse if (that.portal != \"menuPortal\")\n{\n    destroy(links.abBot);\n}","remember":"🔗e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","abManifestBot":"@if (tags.abBot)\n{\n    destroy(links.abBot);\n}\n\nlet ab = {};\n\nab.space = \"tempLocal\";\nab.color = links.remember.tags.abBaseColor;\nab.onClick = \"@ links.manager.abClick();\";\nab.dimension = that.dimension;\nab.scale = 0.001;\nab.maxScale = 1.1;\nab.minScale = 0.5;\nab.grow = false;\nab.form = \"sphere\";\nab[that.dimension] = true;\nab[that.dimension + \"X\"] = that.position.x;\nab[that.dimension + \"Y\"] = that.position.y;\nab.manager = \"🔗\" + thisBot.id;\n// ab.abMenuRefresh = `@ if (!tags.interval)\n// {\n//     thisBot.onCreate();\n// }\n// `;\nab.animateBot = `@\n\nlinks.manager.lerp(thisBot);\n\nawait animateTag(thisBot,\n{\n    fromValue: {\n        scale: tags.scale\n    },\n    toValue: {\n        scale: math.random(tags.minScale, tags.maxScale)\n    },\n    easing: {\n        type: \"sinusoidal\",\n        mode: \"inout\"\n    },\n    duration: 0.8\n}).catch(e => {});\n`;\nab.onCreate = `@ thisBot.animateBot();\n\nmasks.interval = setInterval(() => thisBot.animateBot(), 800);`;\nab.onDestroy = `@\nclearInterval(tags.interval);\n\nshout(\"abMenuRefresh\");\n`;\nab.draggable = false;\n\nlet abManifested = await create(ab);\n\nmasks.abBot = \"🔗\" + abManifested.id;\n\nlinks.remember.masks.abActiveDimension = that.dimension;","abManifestState":"Asleep","abManifestStateAsleepOnEnter":"@destroy(links.abBot);\n\nmasks.abBot = null;\n\nlinks.remember.tags.abAwakeState = false;","onGridClick":"@if (!links.remember.tags.abAwakeState)\n{\n    return;\n}\n\nshout(\"abMenuRefresh\");\n\nlet abFootprint = {};\n\nabFootprint.space = \"tempLocal\";\nabFootprint[that.dimension] = true;\nabFootprint.dimension = that.dimension;\nabFootprint[that.dimension + \"X\"] = that.position.x;\nabFootprint[that.dimension + \"Y\"] = that.position.y;\nabFootprint.scaleZ = 0.01;\nabFootprint.onClick = `@ clearTimeout(tags.timeout);\n\ntags.pointable = false;\n\nlinks.manager.abManifestBot(tags.positionInfo);\n\nawait os.sleep(1000);\n\nawait animateTag(thisBot, \"scale\", {\n    fromValue: 1,\n    toValue: 0.01,\n    duration: 1,\n    easing: {\n        type: \"elastic\",\n        mode: \"out\"\n    }\n}).catch(e => {});\n\ndestroy(thisBot);`;\nabFootprint.positionInfo = that;\nabFootprint.color = \"#ffffff\";\nabFootprint.form = \"sprite\";\nabFootprint.draggable = false;\nabFootprint.formAddress = tags.abImage;\nabFootprint.manager = \"🔗\" + thisBot.id;\nabFootprint.onCreate = `@ masks.timeout = setTimeout(() => destroy(thisBot), 800);\n\n    await animateTag(thisBot, {\n        fromValue: {\n            scaleX: 0.1,\n            scaleY: 0.1\n        },\n        toValue: {\n            scaleX: 1.1,\n            scaleY: 1.1\n        },\n        duration: 0.5,\n        easing: {\n            type: \"elastic\",\n            mode: \"out\"\n        }\n    }).catch(e => {});\n`;\n\ncreate(abFootprint);","menu":"🔗b30c6c5d-a4f7-4266-ba38-393dc95e1ecb","abClick":"@if (!links.abBot)\n{\n    return;\n}\n\nconst menuType = that ? that.menu : \"core\";\nconst state = os.getInputState(\"keyboard\", \"Shift\");\n\nif (links.abBot.masks.interval || state)\n{\n    clearInterval(links.abBot.tags.interval);\n\n    clearAnimations(links.abBot);\n\n    links.abBot.masks.interval = null;\n\n    const rotZ = links.abBot.tags.dimension + \"RotationZ\";\n\n    if (state && menuType != \"multipleBot\")\n    {\n        links.menu.abEnvironmentMenu();\n    }\n    else\n    {\n        links.menu.abOpenMenu(menuType);\n    }\n\n    await animateTag(links.abBot,\n    {\n        fromValue: {\n            [rotZ]: links.abBot.tags[rotZ],\n            scale: links.abBot.tags.scale\n        },\n        toValue: {\n            [rotZ]: 0,\n            scale: 0.9\n        },\n        easing: {\n            type: \"sinusoidal\",\n            mode: \"inout\"\n        },\n        duration: 0.5\n    }).catch(e => {});\n}\nelse\n{\n    links.abBot.animateBot();\n\n    links.abBot.masks.lineTo = null;\n\n    if (links.abBot.tags.arm)\n    {\n        destroy(links.abBot.links.arm);\n    }\n\n    shout(\"abMenuRefresh\");\n\n    links.abBot.masks.interval = setInterval(() => links.abBot.animateBot(), 800);\n}\n","abManifestStateAwakeOnEnter":"@links.remember.tags.abAwakeState = true;\n\nlet dimension = configBot.tags.mapPortal ? configBot.tags.mapPortal : configBot.tags.gridPortal;\n\nif (!dimension)\n{\n    return;\n}\n\nthisBot.abManifestBot({dimension: dimension, position: {x: 0, y: 0}});","onAnyBotDrag":"@if (that.bot != links.abBot) return;\n\nif (links.abBot.tags.arm)\n{\n    destroy(links.abBot.links.arm);\n}\n\nif (!that.bot.tags.interval)\n{\n    thisBot.abClick();\n}\n\nlet state = os.getInputState(\"keyboard\", \"Shift\");\nlet arm = {};\n\narm.space = \"tempLocal\";\narm[that.from.dimension] = true;\narm.dimension = that.from.dimension;\narm.form = \"sphere\";\narm.color = \"#ffffff\";\narm.scale = 0.25;\narm.strokeColor = links.remember.tags.abBaseColor;\narm.lineColor = links.remember.tags.abBaseColor;\narm.lineTo = that.bot.id;\narm.manager = \"🔗\" + thisBot.id;\narm.onClick = `@ destroy(thisBot);\n\nlinks.manager.abManifestBot({dimension: tags.dimension, position:{x:tags[tags.dimension + \"X\"],y:tags[tags.dimension + \"Y\"]}});`;\n\nif (state)\n{\n    arm.multiSelect = true;\n    arm.form = \"sphere\";\n    arm.color = links.remember.tags.abBaseColor;\n}\n\nlet newArm = await create(arm);\n\nlinks.abBot.masks.arm = \"🔗\" + newArm.id;\n\nos.replaceDragBot(newArm);","onAnyBotDropEnter":"@if (!tags.abBot) return;\nif (links.abBot.links.arm != that.dragBot) return;\n\nif (links.abBot.links.arm.tags.multiSelect)\n{\n    if (Array.isArray(links.abBot.tags.lineTo))\n    {\n        links.abBot.masks.lineTo.push(that.to.bot.id);\n    }\n    else\n    {\n        links.abBot.masks.lineTo = [that.to.bot.id];\n    }\n\n    let newLink;\n\n    if (!links.abBot.links.arm.tags.selectedBots)\n    {\n        newLink = getLink(that.to.bot);\n    }\n    else\n    {\n        let previousLinkBots = links.abBot.links.arm.links.selectedBots;\n\n        if (!Array.isArray(previousLinkBots))\n        {\n            previousLinkBots = [previousLinkBots]\n        }\n\n        previousLinkBots.push(that.to.bot);\n\n        newLink = getLink(previousLinkBots);\n    }\n\n    links.abBot.links.arm.tags.selectedBots = newLink;\n}\nelse\n{\n    links.abBot.links.arm.masks.form = \"nothing\";\n    links.abBot.links.arm.masks.lineTo = false;\n\n    links.abBot.masks.lineTo = that.to.bot.id;\n}","onAnyBotDropExit":"@if (!tags.abBot) return;\nif (links.abBot.links.arm != that.dragBot) return;\n\nif (!links.abBot.links.arm.tags.multiSelect)\n{\n    links.abBot.links.arm.masks.form = null;\n    links.abBot.links.arm.masks.lineTo = null;\n\n    links.abBot.masks.lineTo = links.abBot.links.arm.id;\n}\n\n","onAnyBotDrop":"@if (!tags.abBot) return;\nif (links.abBot.links.arm != that.dragBot) return;\n\nif (links.abBot.links.arm.tags.multiSelect)\n{\n    links.remember.masks.abMultipleBotFocus = links.abBot.links.arm.tags.selectedBots;\n\n    thisBot.abClick({menu: \"multipleBot\"});\n\n    destroy(links.abBot.links.arm);\n}\nelse if (that.to.bot)\n{\n    if (that.to.bot == links.abBot)\n    {\n        links.menu.abEnvironmentMenu();\n    }\n    else\n    {\n        links.remember.masks.abBotFocus = \"🔗\" + that.to.bot.id;\n\n        thisBot.abClick({menu: \"bot\"});\n    }\n\n    destroy(links.abBot.links.arm);\n}\nelse\n{\n    links.remember.masks.abGridFocus = {dimension: that.to.dimension, position: {x: that.to.x, y: that.to.y}};\n\n    thisBot.abClick({menu: \"grid\"});\n}","abIgnore":"true","abBotVersion":31,"lerp":"@let abBot = that;\n\nif (!abBot.tags.lerpNumber) \n{\n    abBot.tags.targetColor = tags.abColorArray[math.randomInt(0, tags.abColorArray.length)];\n\n    abBot.tags.lerpNumber = 1;\n}\n\nlet newValue = lerpColor(abBot.tags.color, abBot.tags.targetColor, 0.1);\n\nabBot.tags.color = newValue;\n\nabBot.tags.lerpNumber++;\n\nif (abBot.tags.lerpNumber >= 50) {\n    abBot.tags.lerpNumber = null;\n}\n\nfunction lerpColor(a, b, amount) { \n\n    var ah = parseInt(a.replace(/#/g, ''), 16),\n        ar = ah >> 16, ag = ah >> 8 & 0xff, ab = ah & 0xff,\n        bh = parseInt(b.replace(/#/g, ''), 16),\n        br = bh >> 16, bg = bh >> 8 & 0xff, bb = bh & 0xff,\n        rr = ar + amount * (br - ar),\n        rg = ag + amount * (bg - ag),\n        rb = ab + amount * (bb - ab);\n\n    return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb | 0).toString(16).slice(1);\n}","abColorArray":"🧬[\"#3D9DD9\", \"#79C4F2\", \"#F2D22E\", \"#F2C12E\", \"#89DA59\"]","abImage":"https://publicos-link-filesbucket-404655125928.s3.amazonaws.com/ab-1/fc8858c061aad2ee00df1b017c3695b837d99eee756cec0d09b387fd027814ec.png"}},"e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7":{"id":"e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","space":"shared","tags":{"system":"ab.core.remember","form":"nothing","abCore":true,"abAwakeState":true,"description":"This is meant to be the local state holder.","abRecordKey":"vRK1.YWItMQ==.NHZsUGtoNmFGY3FJdjJTMms1NFlqUT09","abActiveDimension":"home","abBaseColor":"#ffffff","abGridSnapState":true,"abBotSnapState":true,"abMenuRefresh":"@//clear temporary vaiables\nclearTagMasks(thisBot);","initialBoot":false,"abEndpoint":"https://publicos.link/","abIgnore":"true","abCoreVersion":"9","abBotVersion":59,"abCoreIteration":59,"abListeningForFileUploads":"true","baseAB":"f35c480f-63dc-43f2-8370-ae47935b2883","playerSkillArray":"🧬[\"abShell\"]","builderSkillArray":"🧬[\"abShell\", \"abInterface\", \"abAction\", \"abFactory\", \"abTests\"]","abBuilderIdentity":"ao","immersiveSkillArray":"🧬[\"abImmersive\"]"}},"eb75f55a-2bb9-4372-bf8c-ccbac86390ff":{"id":"eb75f55a-2bb9-4372-bf8c-ccbac86390ff","space":"shared","tags":{"color":"#7B64FF","dimension":"home","form":"hex","scale":2,"scaleZ":"0.75","onClick":"@thisBot.openPortal(that);","onPointerEnter":"@masks.scale = 2.1;","onDropEnter":"@if (that.dragBot.id != thisBot.id) //MAYBE MAKE A WAY FOR AB TO NOT INTERACT\n{\n    thisBot.onClick();\n}","system":"ab.factory.portal","onPointerExit":"@masks.scale = null;","abBotVersion":10,"abFactory":"true","abIgnore":"true","toolManager":"🔗14e1fdac-cfd7-4e7e-bdd1-967a4085a755","listening":"false","factoryIcon":"topic","openPortal":"@const currentDim = configBot.tags.mapPortal ? configBot.tags.mapPortal : configBot.tags.gridPortal;\nconst a = Math.PI / 6;\nconst hexScale = 5;\nconst portalDimension = tags.portalAddress;\n\nlet hex = {};\nlet hexNum = 1;\n\nhex.space = \"tempLocal\";\nhex.portalReset = \"@ destroy(thisBot);\";\nhex.form = \"hex\";\nhex.color = tags.color;\nhex.origin = thisBot.id;\nhex.portalHex = true;\nhex[currentDim+\"Z\"] = -1;\nhex.anchorPoint = \"top\";\nhex.scale = 4.5;\nhex[currentDim] = true;\nhex.pointable = false;\nhex.scaleZ = 0.01;\nhex.animate = `@ animateTag(thisBot, \"scale\", {\n    fromValue: tags.scale,\n    toValue: [that],\n    easing: {\n        type: \"quadratic\",\n        mode: \"out\"\n    },\n    duration: 0.3\n}).catch(e => { });`;\n\nlet dimensionBots = getBots(portalDimension, true);\nlet ringNum;\n\nif (dimensionBots.length > 0)\n{\n    let xParameter = dimensionBots.sort((a, b)=> Math.abs(b.tags[portalDimension+\"X\"]) - Math.abs(a.tags[portalDimension+\"X\"]))[0].tags[portalDimension+\"X\"];\n    let yParameter = dimensionBots.sort((a, b)=> Math.abs(b.tags[portalDimension+\"Y\"]) - Math.abs(a.tags[portalDimension+\"Y\"]))[0].tags[portalDimension+\"Y\"];\n\n\n    let distance = Math.floor(Math.sqrt(Math.pow(Math.floor(Math.abs(xParameter - 0)), 2) + Math.pow(Math.floor(Math.abs(yParameter - 0)), 2)) / hexScale) + 1;\n    ringNum = 6 * (distance)*(distance+1)/2 + 1;\n\n    if (ringNum > 397)\n    {\n        ringNum = 397;\n    }\n}\nelse\n{\n    ringNum = 7;\n}\n\nmasks.scale = 0.1;\nmasks.pointable = false;\n\nlet previousHex;\n\nfor (let i = 0; i < ringNum; i++)\n{\n    if (i != 0)\n    {\n        let emptyPos = await checkHexPos(previousHex, currentDim);\n\n        if (emptyPos == 0 || emptyPos == 3)\n        {\n            var x = previousHex.tags[currentDim+\"X\"];\n            \n            var flipX = 1;\n            \n            if (emptyPos == 0)\n            {\n                var flipY = 0;\n                var y = previousHex.tags[currentDim+\"Y\"] + hexScale;\n            }\n            else\n            {\n                var flipY = -1;\n                var y = previousHex.tags[currentDim+\"Y\"] - hexScale/2;\n            }\n        }\n        else\n        {\n            var x = previousHex.tags[currentDim+\"X\"] + (hexScale * 0.85);\n            var y = previousHex.tags[currentDim+\"Y\"];\n\n            if (emptyPos == 1)\n            {\n                var flipX = 1;\n                var flipY = 1;\n            }\n            else if (emptyPos == 2)\n            {\n                var flipX = 1;\n                var flipY = -1;\n            }\n            else if (emptyPos == 4)\n            {\n                x = previousHex.tags[currentDim+\"X\"] - (hexScale * 0.85);\n\n                var flipX = 1;\n                var flipY = -1;\n            }\n            else if (emptyPos == 5)\n            {\n                x = previousHex.tags[currentDim+\"X\"] - (hexScale * 0.85);\n                \n                var flipX = 1;\n                var flipY = 1;\n            }\n        }\n\n        hex[currentDim+\"X\"] = x * flipX;\n        hex[currentDim+\"Y\"] = y + flipY * hexScale/2;\n    }\n    else\n    {\n        hex[currentDim+\"X\"] = tags[currentDim+\"X\"];\n        hex[currentDim+\"Y\"] = tags[currentDim+\"Y\"];\n    }\n\n    hex.hexNum = hexNum;\n\n    let nearbyPortalBot = getBot(byMod({//being mirrored right now\n        [portalDimension]: true,\n        [portalDimension+\"X\"]: x => x > (hex[currentDim+\"X\"] - tags[currentDim+\"X\"]) - hexScale && x < (hex[currentDim+\"X\"] - tags[currentDim+\"X\"]) + hexScale,\n        [portalDimension+\"Y\"]: y => y > (hex[currentDim+\"Y\"] - tags[currentDim+\"Y\"]) - hexScale && y < (hex[currentDim+\"Y\"] - tags[currentDim+\"Y\"]) + hexScale\n    }));\n\n    if (nearbyPortalBot || i < 7)\n    {\n        hex.onPortalComplete = false;\n        hex.color = tags.color;\n    }\n    else\n    {\n        hex.onPortalComplete = true;\n        hex.color = \"clear\";\n    }\n\n    hexNum++;\n\n    previousHex = await create(hex);\n}\n\nlet nonPortalHexes = getBots(\"onPortalComplete\", true);\nlet portalHexes = getBots(\"onPortalComplete\", false);\n\nfor (let n = 0; n < nonPortalHexes.length; n++)\n{\n    destroy(nonPortalHexes[n]);\n}\n\nwhisper(portalHexes, \"animate\", hexScale);\n\nmasks.form = \"portal\";\nmasks.formAddress = tags.portalAddress;\nmasks.portalHexBots = getLink(portalHexes);\n\nthisBot.portalMenu();\n\nfunction checkHexPos(hex, dimension)\n{\n    let scaleVar = hexScale/2;\n    let xPos = hex.tags[dimension+\"X\"];\n    let yPos = hex.tags[dimension+\"Y\"];\n    let hexMathVar = Math.PI / 6;\n    let xSpacingPlus = xPos + scaleVar + (1 + Math.cos(hexMathVar));\n    let xSpacingMinus = xPos - (scaleVar + (1 + Math.cos(hexMathVar)));\n    let ySpacingTop = Math.floor(hex.tags.scale) + yPos;\n    let ySpacingUp = yPos + scaleVar * Math.sin(hexMathVar);\n    let ySpacingDown = yPos - scaleVar * Math.sin(hexMathVar);\n    let ySpacingBottom = yPos - Math.floor(hex.tags.scale);\n    let xCheck = [xPos, xSpacingPlus, xSpacingPlus, xPos, xSpacingMinus, xSpacingMinus];\n    let yCheck = [ySpacingTop, ySpacingUp, ySpacingDown, ySpacingBottom, ySpacingDown, ySpacingUp];\n    let totalNeighbors = 0;\n    let neighborArray = []\n\n    for (let i = 0; i < 6; i++)\n    {\n        let hexNeighbor = getBot(byMod({\n            [dimension]: true, \n            [dimension+\"X\"]: x => x > xCheck[i] - scaleVar && x < xCheck[i] + scaleVar, \n            [dimension+\"Y\"]: y => y > yCheck[i] - scaleVar && y < yCheck[i] + scaleVar,\n            origin: hex.tags.origin,\n            portalHex: true\n        }));\n\n        if (!hexNeighbor)\n        {\n            neighborArray.push(\"empty\");\n        }\n        else\n        {\n            neighborArray.push(hexNeighbor);\n            totalNeighbors++;\n        }\n    }\n\n    if (totalNeighbors == 0)\n    {\n        var target = 0;\n    }\n    else\n    {\n        var empty = false;\n\n        for (let j = 0; j < 6; j++)\n        {\n            let nextEmpty = neighborArray[j];\n\n            if (nextEmpty == \"empty\")\n            {\n                empty = true;\n\n                if (j == 5)\n                {\n                    var target = 5;\n                }\n            }\n            if(nextEmpty != \"empty\" && empty)\n            {\n                var target = j-1;\n                break;\n            }\n        }\n    }\n    return target;\n}","pointable":"true","onGridClick":"@if (tags.form != \"portal\")\n{\n    return;\n}\n\nlet portalClick = thisBot.portalPositionCheck(that);\n\nif (!portalClick)\n{\n    thisBot.closePortal();\n}","closePortal":"@whisper(links.portalHexBots, \"portalReset\");\n\nconfigBot.masks.menuPortal = null;\n\nclearTagMasks(thisBot);","portalMenu":"@shout(\"abPortalMenuReset\");\n\nconfigBot.masks.menuPortal = \"abPortalMenu\";\n\nlet menuButton = {};\n\nmenuButton.space = \"tempLocal\";\nmenuButton.abPortalMenu = true;\nmenuButton.abPortalMenuReset = \"@ destroy(thisBot);\";\nmenuButton.color = tags.color;\nmenuButton.manager = getLink(thisBot);\nmenuButton.menuItemStyle = `🧬 {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\nmenuButton.labelAlignment = \"center\";\nmenuButton.label = tags.portalAddress;\n\ncreate(menuButton);\n\nmenuButton.formAddress = \"edit\";\nmenuButton.labelAlignment = \"left\";\nmenuButton.label = \"edit dimension\";\nmenuButton.target = thisBot.id;\nmenuButton.onClick = `@ links.manager.portalChangeDimension();`;\n\ncreate(menuButton);\n\nmenuButton.formAddress = \"arrow_forward\";\nmenuButton.labelAlignment = \"left\";\nmenuButton.label = \"go to dimension\";\nmenuButton.target = tags.formAddress;\nmenuButton.onClick = `@ shout(\"abPortalMenuReset\");\n\nconfigBot.tags.gridPortal = links.manager.tags.portalAddress;`;\n\ncreate(menuButton);","onCreate":"@if (!tags.portalAddress)\n{\n    tags.portalAddress = uuid();\n}","portalPositionCheck":"@let currentDim = that.dimension ? that.dimension : that.to.dimension;\nlet posY = that.position ? that.position.y : that.to.y;\nlet posX = that.position ? that.position.x : that.to.x;\nlet portalHexBots = links.portalHexBots;\nlet portalEntry = false;\n\nfor (let i = 0; i < portalHexBots.length; i++) \n{\n    let currentHex = portalHexBots[i];\n    let maxY = currentHex.tags[currentDim + \"Y\"] + currentHex.tags.scale / 2;\n    let minY = currentHex.tags[currentDim + \"Y\"] - currentHex.tags.scale / 2;\n\n    if (posY <= maxY && posY >= minY) {\n\n        //SETUP A CHECK FOR WHEN X = DECK X\n        let maxX = currentHex.tags[currentDim + \"X\"] + currentHex.tags.scale / 2 + 0.5;\n        let minX = currentHex.tags[currentDim + \"X\"] - currentHex.tags.scale / 2 - 0.5;\n\n        if (posX <= maxX && posX >= minX) {\n            if (posX <= currentHex.tags[currentDim + \"X\"] + 0.3 && posX >= currentHex.tags[currentDim + \"X\"] - 0.3)//not perfect part of alg\n            {\n                if (posY >= currentHex.tags[currentDim + \"Y\"] - currentHex.tags.scale / 2 && posY <= currentHex.tags[currentDim + \"Y\"] + currentHex.tags.scale / 2) \n                {\n                    portalEntry = true;\n\n                    break;\n                }\n            }\n\n            let midX = currentHex.tags[currentDim + \"X\"];\n            let midY = currentHex.tags[currentDim + \"Y\"];\n            const a = Math.pow(currentHex.tags.scale / 2, 2);\n            const b = Math.pow(a / 2, 2);\n            const maxDistance = Math.sqrt(Math.abs(a - b));\n            let slope;\n\n            if ((posX > midX && posY > midY) || (posX < midX && posY < midY)) \n            {\n                slope = (maxY - minY) / (maxX - minX);\n            }\n            else {\n                if (posX > midX)\n                {\n                    slope = (maxX - minX) / (maxY - minY);\n                }\n                else \n                {\n                    slope = 1 / (maxX - minX) / (maxY - minY);\n                }\n            }\n\n            let c1 = maxY - (maxX * slope);\n            let c2 = posY - (posX * slope);\n            let actualDistance = Math.abs(c2 - c1) / Math.sqrt(Math.pow(slope, 2) + 1);\n\n            if (actualDistance <= maxDistance) \n            {   \n                portalEntry = true;\n\n                break;\n            }\n        }\n    }\n\n    //NOT SURE OF THIS CODES NEED?\n    // if (that.portalID) \n    // {\n    //     if (that.portalID == currentHex.tags.origin) \n    //     {\n    //         portalEntry = true;\n\n    //         break;\n    //     }\n    // }\n}\n\n// let portalBots = getBots(\"portalHexBots\");//CHECK TO SEE IF THERE ARE OTHER OPEN PORTAL (not sure I need this)\n\n// for (let i = 0; i < portalBots.length; i++) \n// {\n//     if (portalBots[i].id != thisBot.id) \n//     {\n//         whisper(portalBots[i], \"closePortal\");\n//     }\n// }\n\nreturn portalEntry;","onAnyBotDrop":"@if (that.dragBot.id == thisBot.id)\n{\n    clearInterval(tags.interval);\n\n    masks.interval = null;\n\n    return;\n}\n\nif (tags.form != \"portal\")\n{\n    return;\n}\n\nconst currentDim = that.to.dimension;\nconst portalDrop = await thisBot.portalPositionCheck(that);\n\nif (portalDrop) \n{\n    let newDim = tags.portalAddress;\n\n    that.dragBot.tags[newDim] = true;\n    that.dragBot.tags[newDim + \"X\"] = that.dragBot.tags[currentDim + \"X\"] - tags[currentDim + \"X\"];\n    that.dragBot.tags[newDim + \"Y\"] = that.dragBot.tags[currentDim + \"Y\"] - tags[currentDim + \"Y\"];\n    that.dragBot.tags[currentDim] = null;\n}","onDrag":"@if (!tags.interval)\n{\n    masks.interval = setInterval(() => thisBot.positionCheck(), 100);\n}","portalChangeDimension":"@const newDimension = await os.showInput(tags.portalAddress, {\n    title: \"edit dimension\"\n});\n\nif (!newDimension)\n{\n    return;\n};\n\ntags.portalAddress = newDimension;\n\nthisBot.portalMenu();","positionCheck":"@let height = gridPortalBot.tags.pixelHeight;\nlet botThird = height - (height / 8);\nlet pointerY = gridPortalBot.tags.pointerPixelY;\n\nif (pointerY > botThird)\n{\n    if (configBot.tags.miniGridPortal != tags.portalAddress)\n    {\n        configBot.tags.miniGridPortal = tags.portalAddress;\n\n        miniGridPortalBot.tags.miniPortalWidth = 1;\n\n        miniGridPortalBot.tags.portalColor = tags.color;\n    }\n}\nelse\n{\n    if (configBot.tags.miniGridPortal == tags.portalAddress)\n    {\n        configBot.tags.miniGridPortal = null;\n        miniGridPortalBot.tags.portalColor = null;\n        miniGridPortalBot.tags.miniPortalWidth = null;\n    }\n}\n\n\n\n\n// if (that.bot.tags.primitiveID)\n// {\n//     if (that.bot.tags.primitiveID == \"portal\")\n//     {\n//         let portalBot = that.bot;\n\n//         clearInterval(portalBot.masks.interval);\n//         clearTagMasks(portalBot);\n\n//         if (that.to.dimension != that.from.dimension)\n//         {\n//             if (that.to.dimension == portalBot.tags.portalAddress)\n//             {\n//                 configBot.tags.miniGridPortal = portalBot.tags.portalAddress;\n\n//                 miniGridPortalBot.tags.miniPortalWidth = 1;\n\n//                 portalBot.tags[that.to.dimension + \"X\"] = 0;\n//                 portalBot.tags[that.to.dimension + \"Y\"] = 0;\n//             }\n//             else if (configBot.tags.miniGridPortal == portalBot.tags.portalAddress && that.to.dimension != portalBot.tags.portalAddress)\n//             {\n//                 configBot.tags.miniGridPortal = null;\n//             }\n//         }\n//     }\n// }","abMenuSortOrder":"0"}},"f8602878-c2ef-48bd-85a0-8d6351eb4120":{"id":"f8602878-c2ef-48bd-85a0-8d6351eb4120","space":"shared","tags":{"system":"ab.shell.input","form":"nothing","onKeyDown":"@//allow pulling up chat in builder version\nif (that.keys == \"`\" && builderVersion)\n{\n    os.showChat();\n}","onChat":"@//not supported outside of builder version\nif (!builderVersion)\n{\n    return;\n}\n\n//this loop identifies possible ab specific messages, and calls a set list of commands\nif (that.message[0] == \".\") \n{\n    os.hideChat();\n\n    switch (that.message)\n    {\n        case '.downloadAB':\n            changeState(links.manifestation, \"Asleep\", \"abManifestState\");\n\n            const group = await os.showInput(\"group\");\n\n            if (group == \"abCore\")\n            {\n                links.remember.tags.abCoreIteration++;\n                links.remember.tags.initialBoot = true;\n                links.remember.tags.coreAB = null;\n                links.remember.tags.hostID = null;\n            }\n\n            const abGroup = getBots(group);\n\n            for (let i = 0; i < abGroup.length; i++)\n            {\n                abGroup[i].tags.abBotVersion++;\n            }\n            \n            os.downloadBotsAsInitialzationUpdate(abGroup, group);\n            break;\n        case `.loadSkill`:\n            let skill = await os.showInput(\"skill\");\n\n            links.learn.abAdapt(skill);\n            break;\n        case `.system`:\n            configBot.tags.systemPortal = true;\n\n            break;\n        case `.sheet`:\n            configBot.tags.sheetPortal = !configBot.tags.mapPortal ? configBot.tags.gridPortal : configBot.tags.mapPortal;\n\n            break;\n        case `.menuSheet`:\n            configBot.tags.sheetPortal = configBot.tags.menuPortal;\n\n            break;\n        case `.download`:\n            os.downloadBots(getBots(byMod({space: \"shared\", abIgnore: null})), configBot.tags.inst);\n\n            break;\n        case `.upload`:\n            os.showUploadAuxFile();\n\n            break;\n        case `.sleep`:\n            changeState(links.manifestation, \"Asleep\", \"abManifestState\");\n\n            break;\n        case `..`:\n            changeState(links.manifestation, \"Awake\", \"abManifestState\");\n\n            await thisBot.abAdapt(\"abInterface\");\n\n            break;\n        case '.log':\n            if (configBot.tags.tagPortal == ab.id + \".abLog\")\n            {\n                configBot.masks.tagPortal = null;\n                configBot.masks.tagPortalSpace = null;\n\n                tagPortalBot.masks.tagPortalAnchorPoint = null;\n\n                os.hideChat();\n            }\n            else\n            {\n                configBot.masks.tagPortal = ab.id + \".abLog\";\n                configBot.masks.tagPortalSpace = \"tempLocal\";\n\n                tagPortalBot.masks.tagPortalAnchorPoint = \"top\";\n\n                os.showChat();\n            }\n            break;\n        case '.hideLog':\n            configBot.masks.tagPortal = null;\n            configBot.masks.tagPortalSpace = null;\n\n            tagPortalBot.masks.tagPortalAnchorPoint = null;\n\n            os.hideChat();\n            break;\n        default:\n            let message = that.message;\n            let executable = message.slice(1);\n\n            try\n            {\n                os.run(executable);  \n            }\n            catch (e)\n            {\n                console.log(e);\n            }\n    }\n}","description":"This is meant to handle any none menu related inputs/interactions.","onFileUpload":"@//filter out times when file loading is not allowed\nif (!builderVersion || links.remember.tags.abListeningForFileUploads !== true)\n{\n    return;\n}\n\n//various file specific variables\nlet fileExtension = that.file.name.split('.').pop();\nlet fileName = that.file.name.split('.').shift();\nlet size = that.file.size;\nlet mimeType;\nlet botInfo = {};\n\n//hard limit based on file size\nif (size > 200000000)\n{\n  os.toast(\"maximum file size exceeded (200 mb)\");\n\n  return;\n}\n\n//this switch handles possible files extensions, while rejecting any it does not recognize\nswitch(fileExtension)\n{\n  case 'jpg':\n  case 'jpeg':\n  case 'webp':\n  case 'gif':\n  case 'png':\n    mimeType = \"image/\" + fileExtension;\n    botInfo.form = \"sprite\";\n    break;\n  case 'svg':\n    mimeType = \"image/svg+xml\";\n    botInfo.form = \"sprite\";\n    break;\n  case 'glb':\n  case 'gltf':\n    mimeType = \"text/xml\";\n    botInfo.form = \"mesh\";\n    botInfo.formSubtype = \"gltf\";\n    break;\n  case 'aux':\n  case 'pdf':\n    let botData = fileExtension == \".aux\" ? JSON.parse(that.file.data).state : os.parseBotsFromData(that.file.data);\n\n    links.create.abCreateBots({bots: botData, origin: fileName});\n\n    return;\n//   case 'pdf':\n//     break;\n  case 'mp3':\n    mimeType = 'audio/mpeg';\n    botInfo.onClick = \"@ os.playSound(tags.formAddress);\";\n    botInfo.label = \"Click to Play\";\n    break;\n  case 'mp4':\n    mimeType = 'video/mp4';\n    botInfo.form = \"iframe\";\n    botInfo.formSubtype = \"src\";\n    break;\n  default:\n    let result = new Error(\"unhandled file type: \" + fileExtension);\n    os.toast(\"file type not supported\");\n    console.warn(result)\n    return result;\n}\n\n//the following variables and objects set up a loading bar button\nconfigBot.masks.menuPortal = \"abMenu\";\n\nlet uploadResult;\nlet menuButton = {};\n\nmenuButton.abMenu = true;\nmenuButton.trackNum = -1;\nmenuButton.onCreate = `@\n    if (tags.trackNum == 2)\n    {\n        tags.trackNum = 0;\n    }\n    else\n    {\n        tags.trackNum++;\n    }\n\n    tags.label = tags[\"label\"+tags.trackNum];\n    tags.formAddress = tags[\"form\"+tags.trackNum];\n\n    setTimeout(() => whisper(thisBot, \"onCreate\"), 500);`;\nmenuButton.label0 = \"uploading.\";\nmenuButton.label1 = \"uploading..\";\nmenuButton.label2 = \"uploading...\";\nmenuButton.form0 = \"hourglass_bottom\";\nmenuButton.form1 = \"hourglass_top\";\nmenuButton.form2 = \"hourglass_bottom\";\nmenuButton.color = \"#908BFC\";\nmenuButton.onDestroy = \"@ configBot.masks.menuPortal = null;\";\n\nprogressButton = links.menu.abCreateMenuButton(menuButton);\n\n//this is the actual upload functionality\nuploadResult = await links.store.abPublishFile({file: that.file.data, fileName: fileName, mimeType: mimeType});\n\n//if the file should be included as a bot with a link, this logic handles that\nif (Object.keys(botInfo).length > 0)\n{\n    botInfo[configBot.tags.gridPortal] = true;\n    botInfo.formAddress = uploadResult.url ? uploadResult.url : uploadResult.existingFileUrl;\n\n    create(botInfo);\n}\n\n//clear the progress bar button\nconfigBot.masks.menuPortal = null;\n\ndestroy(progressButton);\n\nreturn uploadResult;","learn":"🔗6657b865-e983-4401-9fc9-f5418d18a7f7","remember":"🔗e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","manifestation":"🔗dca5d987-c4d8-46e4-b60c-daa7b2f4ddad","abIgnore":"true","abBotVersion":54,"create":"🔗34c3c210-5bf1-49cf-b151-ee2d07f0e673","store":"🔗76af0491-3919-4984-aa82-22c742f4263f","menu":"🔗b30c6c5d-a4f7-4266-ba38-393dc95e1ecb","abShell":"true"}},"f9fd7e2e-7cce-43fb-b223-d32cb42bebe8":{"id":"f9fd7e2e-7cce-43fb-b223-d32cb42bebe8","space":"shared","tags":{"system":"ab.action.color_bot","form":"nothing","abAction":"true","abBotMenuAction":"@const targetBot = links.remember.links.abBotFocus;\n\nos.showInputForTag(targetBot, \"color\", {\n    type: 'color',\n    title: 'pick a color'\n});","abBotMenuLabel":"color","abBotMenuIcon":"palette","remember":"🔗e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","abBotMenuSortOrder":"2","abIgnore":"true","abBotVersion":31,"abBotMenuColor":"#55E679"}}}}